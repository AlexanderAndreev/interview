======================
= Class (Type, File) =
======================


Итак – ссылки в Java это, фактически, указатели. Однако, в отличие от С, арифметика указателей в Java отсутствует. И хорошо – ничего хорошего, кроме плохого, я от этой возможности не видел. А что вообще можно делать с ссылками? Какие операции над ними можно производить?
- Присваивание. Ну это естественно, без этой операции ссылки бы не имели смысла.
- Доступ к полям объекта
- Вызов методов
- Операция приведения типа
- Конкатенация строк (оператор '+')
- Проверка принадлежности к определенному типу – оператор instanceof
- Операции сравнения ссылки – '==' и '!='
- Условный оператор ? :



======================================
= Usage of a Static Block in a Class =
======================================
Static используется в различных контекстах. Переменная, объявленная static, называется переменной класса и все экземпляры класса используют одну и ту же копию этой переменной. Более того, такая переменная может быть использована вообще без создания экземпляров класса. Статический метод так же может быть вызван без создания экземпляра класса.

Поскольку статический метод – это метод класса, а не экземпляра, переопределить его нельзя. Хотя должен заметить, что вызов статического метода на объекте – дурной тон.
- Вы НЕ можете получить доступ к НЕ статическим членам класса, внутри статического контекста, как вариант, метода или блока.
- В отличие от локальных переменных, статические поля и методы НЕ потокобезопасны (Thread-safe) в Java. 
- Статические методы имеют преимущество в применении, т.к. отсутствует необходимость каждый раз создавать новый объект для доступа к таким методам. Статический метод можно вызвать, используя тип класса, в котором эти методы описаны. Именно поэтому, подобные методы как нельзя лучше подходят в качестве методов-фабрик (factory), и методов-утилит (utility). Класс java.lang.Math — замечательный пример, в котором почти все методы статичны, по этой же причине классы-утилиты в Java финализированы (final).
- Другим важным моментом является то, что вы НЕможете переопределять (Override) статические методы. Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass) вместо переопределения. Это явление известно как сокрытие методов (hiding methods). Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной. В отличие от переопределения, такие методы не будут выполнены во время работы программы.
-  Модификатор static также может быть объявлен в статичном блоке, более известным как «Статический блок инициализации» (Static initializer block), который будет выполнен во время загрузки класса. Если вы не объявите такой блок, то Java соберёт все статические поля в один список и выполнит его во время загрузки класса. 
- Полезно знать, что статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте. Следовательно, статические методы не могут быть переопределены в Java, т.к. полиморфизм во время выполнения не распространяется на них.
- Важным свойством статического блока является инициализация. Статические поля или переменные инициализируются после загрузки класса в память. Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса.
- Во время сериализации, также как и transient переменные, статические поля не сериализуются.
- И напоследок, поговорим о static import. Данный модификатор имеет много общего со стандартным оператором import, но в отличие от него позволяет импортировать один или все статические члены класса. При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе, аналогично при импортировании полей, мы можем получить доступ без указания имени класса.

У статического метода нет ссылки this!

Нельзя вызывать нестатические методы из статических. ХИНТ: можно сделать передав ссылку на объект в статический метод. Тогда по переданной ссылке (которая заменяет this) вы сможете вызвать обычные, нестатические, методы и получать доступ к обычным полям.

Static-инициализация выполняется только один раз. Например, при первом создании объекта класса или первом обращении к статическому методу или полю.



========================================================================
= Classloader (Hierarchy:Bootstrap, Extensions, System, User-defined…) =
========================================================================
При реализации пользовательских загрузчиков важно помнить следующее:
- любой загрузчик должен явно или неявно расширять класс java.lang.ClassLoader;
- любой загрузчик должен поддерживать модель делегирования загрузки, образуя иерархию;
- в классе java.lang.ClassLoader уже реализован метод непосредственной загрузки — defineClass(...), который байт-код преобразует в java.lang.Class, осуществляя его валидацию;
- механизм рекурентного поиска также реализован в классе java.lang.ClassLoader и заботиться об этом не нужно;
- для корректной реализации загрузчика достаточно лишь переопределить метод findClass() класса java.lang.ClassLoader.
Classloader иерархия:
Bootstrap
	  |
   System
	  |
   Common
   /     \
Webapp1   Webapp2 ...

Программа на Java никогда не бывает полностью загружена до начала своего выполнения, и в этом отношении Java отличается от многих традиционных языков.
Подготовка класса к использованию состоит из трех этапов:
- Загрузка - выполняется загрузчиком классов. Последний находит байт-код и создает на его основе объект Class.
- Компоновка - в фазе компоновки проверяется байт-код класса, выделяется память для статических полей, и при необходимости разрешаются все ссылки на классы, созданные этим классом.
- Инициализация - если у класса имеется суперкласс, происходит его инициализация, выполняются статические инициализаторы и блоки статической инициализации.

Размер Java объектов (http://habrahabr.ru/post/134102/) - JVM хранит для каждого объекта:
- Заголовок объекта - Заголовок: 8 байт;
- Память для примитивных типов;
- Память для ссылочных типов;
- Смещение/выравнивание — по сути, это несколько неиспользуемых байт, что размещаются после данных самого объекта. Это сделано для того, чтобы адрес в памяти всегда был кратным 
машинному слову, для ускорения чтения из памяти + уменьшения количества бит для указателя на объект + предположительно для уменьшения фрагментации памяти. Стоит также отметить, что в java 
размер любого объекта кратен 8 байтам! + после всего подсчета происходит выравнивание до кратности к 8 байтам.

Classpath – место размещения классов, переменная среды, которая указывается, чтобы показать, где искать классы. Из двух библиотек выберется та, что первой попадётся jvm.



==========
= Object =
==========
 - java.lang - все обьекты обертки, Void, рефлексия, Class, Enum, Exception (Illegal и тд), Thread и тд
 - java.util - коллекции, пакет concurent, рандом, таймер, некоторые эксепшены, TimeZone, UUID
 - java.io. - File



===================== 
= Java OOP          =
=====================
ООП:
- Инкапсуляция (encapsulation) — свойство языка прог. при котором сложные участки кода спрятаны от глаз программиста, и он не должен думать от реалицазии внутри методов. Достигается с помощью public, private  итд.
- Наследование (inheritance) — позволяет включать свойства и логику родительского класса.
- Полиморфизм (polymorphism) — возможность объектов с одинаковой спецификацией иметь различную реализацию. Имеем интерфейс (абстрактный), и классы реализующие его, каждый класс имеет свою логику.
- Абстракция — это выделение общих характеристик объекта,исключая набор незначительных. С помощью принципа абстракции данных,данные преобразуются в объекты. Данные обрабатываются в виде цепочки сообщений между отдельными объектами. Все объекты проявляют свои уникальные признаки поведения. Огромный плюс абстракции в том, что она отделяет реализацию объектов от их деталей, что в свою очередь позволяет управлять функциями высокого уровня через функции низкого уровня

При необходимости множественного наследования или добавить какую-нибудь функциональность классу, то лучше использовать интерфейс. Если класс имеет много методов и полей, которые повторяются для нескольких классов - то лучше абстрактный класс. Абстрактный класс имеет конструктор. В абстрактном классе могут быть неабстрактные методы. В абстрактном классе может быть конструктор, но создать экземпляр такого класса нельзя.
Интерфейсы и абстрактные классы могут содержать абстрактные методы, причём интерфейсы – только абстрактные методы. К тому же, интерфейсы могут содержать только константы. Нельзя создать объект абстрактного класса или интерфейса.
Интерфейс также может содержать поля, но они автоматически являются статическими и неизменными (final). Конечно, поля не являются частью интерфейса. Данные хранятся в статической области памяти, отведенной для данного интерфейса. Поля, определяемые в интерфейсах, не могут быть "пустыми константами", но могут инициализироваться не-константными выражениями. 
Интерфейсы могут вкладываться в классы и в другие интерфейсы. Особо стоит отметить тот факт, что при реализации интерфейса вы не обязаны реализовывать вложенные в него интерфейсы. Так же закрытые интерфейсы нельзя реализовать за пределами классов, в которых они описываются.

Объект – совокупность данных и методов работы с ними.
Класс – это описатель общих свойств группы объектов. Этими свойствами могут быть как характеристики объектов (размер, вес, цвет и т.п.), так и поведения, роли и т.п.



============================
= Constructors and methods =
============================
- Если не определен ни один конструктор, то вызовется конструктор по-умолчанию. Если мы определим любой другой конструктор, то конструктор по-умолчаню уже работать не будет.
- В конструкторе можно вызвать другой конструктор этого же класса. И только ОДИН! Вызов другого конструктора должен быть первой выполняемой операцией, иначе компилятор выдаст сообщение об ошибке.
- Конструктор нельзя вызывать из обычного метода.

Нестатическая инициализация выполняется раньше любых конструкторов. Такой синтаксис необходим для поддержки инициализации анонимных внутренних классов, но он также гарантирует, что некоторые операции будут выполнены независимо от того, какой именно конструктор был вызван в программе.

Единственные методы, которые можно вызывать в конструкторе без опаски - неизменные (final) методы базового класса. (Сказанное относится и к закрытым (private) методам, посколькоу они автоматически являются неизменными.) Такие методы невозможно переопределить, и поэтому они застрахованы от "сюрпризов".
Вызовы из конструктора методов, которые возможно переопределить, потенциально опасны тем, что они вызываются в тот момент, когда объект еще не инициализирован до конца – не отработал код дочернего конструктора.



============================ 
= Constants in Java	       =
============================
Переменная - именованная ячейка памяти для хранения данных определенного типа. 
Константа — это именованная ячейка памяти, способная хранить данные, которые потом изменяться не будут.
Константа— это фактически переменная, объявленная с ключевым словом j (модификатором) final (оно как раз и говорит о том, что значение переменной изменяться не будет).
Любую попытку поменять значение финальной переменной (или поля) компилятор будет воспринимать как ошибку
Хотя класс перечисления (enum) вроде как не финальный (т.е. объявлен без модификатора final и можно его наследовать), дальше расширять наш класс мы уже не можем — этот запрет реализован на уровне компилятора.



====================================================
= Final class, final method, final member variable =
====================================================
Final класс не может иметь наследников. Final метод не может быть переопределен в дочернем классе, final переменная - это переменная, значение которой присваивается лишь однажды и потом не может быть изменено. Ключевое слово final означает, что присвоить какое-либо значение данной переменной можно лишь один раз и навсегда.
Неизменяемый объект - это такой объект, чье внешнее видимое состояние не может измениться после его создания. Классы String, Integer и BigDecimal в библиотеке классов Java являются примерами неизменяемых объектов - они представляют отдельное значение, которое не может измениться в течение жизненного цикла объекта.
IMMUTABLE CLASS
1. Объявить класс final. (лучший подход - создать private-конструктор и создавать сущности factory-методом)
2. Все поля private final.
3. Не использовать set-методы.
4. Использую get-методы лучше передавать не сам объект, а его клон. (таким образом не будет возможности его изменить).



==========================================
= StringBuffer, StringBuilder and String =
==========================================
# new String("") vs ""
Когда используется new(), строка сразу добавляется в heap и НЕ добавляется в string pool. String pool - пул, в котором хранятся все определённые строки. и если создаётся новая, компилятор проверяет, есть ли её значение в пуле, если есть, то вновь созданной присваивается ссылка на уже существующую, таким образом экономится память. Это безопасно, что разные String-и могут ссылаться на один объект, потому что String - immutable. Чтобы добавить строку в пул, используется метод String.intern(); Строки созданные, как String s = "s"; добавляются в пул автоматически.
При использование выражения: String s1 = ""; - в пуле создаётся запись "", при повторном вызове: String s2=""; - ссылка s2 уже ссылается на существующую запись в пуле "", в результате : s1==s2 (так как ссылаются на одну запись в пуле) и s1.equals(s2); При вызове String s3=new String(""); в куче создается новый объект, который ссылается на заново созданное место в пуле и уже s1==s3 выдаст false.

# Почему String в Java является immutable (неизменным после создания)?
- Безопасность.
String широко используется , как параметр для многих классов Java, в частности для открытия сетевых соединений, подключений к БД, открытию файлов и пр. И если бы строка изменялась, то мы могли получить доступ к объекту (файлу например), на который мы имеем право, затем изменить строку с именем (случайно или намеренно) и получить доступ уже к другому файлу.
Так же String используется в механизме загрузки файлов, и это -- фундаментальный аспект. И если бы строка изменялась, то запрос на загрузку "java.io.Writer" мог бы быть изменён на 
"DiskErasingWriter".
- Hashcode
Из-за того, что строка не изменяется, она кэширует свой хэшкод и не вычисляет его каждый раз, когда мы его вызываем, что делает строку очень быстрой как ключ для hashmap.
- Многопоточность
immutable делает экземпляры строк thread-safe.

# Сравнение строк
str.equals("abc"). Тут есть небольшие грабли – перед этим сравнением правильно бы было сравнить str с null, чтобы не получить NullPointerException. Т.е. правильной будет конструкция str != null && str.equals("abc"). Между тем – ее можно упростить. Достаточно написать всего лишь "abc".equals(str). Проверка на null в этом случае не нужна.
 
# Испльзование substring без потери памяти
String str = "abcdefghijklmnopqrstuvwxyz";
str = str.substring(5,10);
Вроде тривиальный код. И первая мысль такая – выбирается подстрока "efghi", переменной str присваивается ссылка на новую строку, а старый объект отбрасывается. Так? Почти.
Дело в том, что для увеличения скорости при выборке подстроки используется ТОТ ЖЕ МАССИВ, что и в исходной строке. Иначе говоря, мы получим не объект, в котором массив value (cм. устройство строки) имеет длину 5 и содержит в себе символы 'e', 'f', 'g', 'h' и 'i', count=5 и offset=0. Нет, длина массива будет по-прежнему 26, count=5 и offset=5. И при отбрасывании старой строки массив НЕ ОТБРОСИТСЯ, а по-прежнему будет находиться в памяти, ибо на него есть ссылка из новой строки. И существовать в памяти он будет до того момента, как будет отброшена уже новая строка. Это совсем неочевидный момент, который может привести к проблемам с памятью.
Возникает вопрос – как этого избежать? Ответ – с помощью копирующего конструктора String(String). Дело в том, что в этом конструкторе в явном виде выделяется память под новую строку, и в эту память копируется содержимое исходной. Таким образом, если мы перепишем код так:
String str = "abcdefghijklmnopqrstuvwxyz";
str = new String(str.substring(5,10));
..., то длина массива value у объекта str будет действительно 5, count=5 и offset=0. И это – единственный случай, где оправдано применение копирующего конструктора для строки.



============================
= Equals/hashCode contract =
============================
Реализация по умолчанию для hashCode() использует System.identityHashcode() метод для получения хэш кода. Этот метод возвращает хэш связанный с адресом памяти, где расположен объект. Конечный эффект использования стандартного выполнения equals() и hashCode() – это, то, что два объекта равны только тогда, когда они являются одним и тем же Java объектом. Для некоторых приложений это нормально, но не для нашего, чаще всего, это является проблемой.

Пользовательские equals() и hashCode() методы необходимы, потому что объекты такие как PixUser могут быть сохранены и извлечены из базы данных. Если вы сравните экземпляр PixUser, созданного при помощи своего конструктора с другим экземпляром, извлеченным из базы данных, то вы захотите чтобы они были равны, если все их значения имеют равные значения. PixUser считается равным нашим приложением если его или ее имя, email, фамилия, имя пользователя и пароль равны. Вам не нужно чтобы они были одинаковыми Java объектами.

HashCode
Хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект. 
Этот метод реализован таким образом, что для одного и того-же входного объекта, хеш-код всегда будет одинаковым. Следует понимать, что множество возможных хеш-кодов ограничено примитивным типом int, а множество объектов ограничено только нашей фантазией. Отсюда следует утверждение: “Множество объектов мощнее множества хеш-кодов”. Из-за этого ограничения, вполне возможна ситуация, что хеш-коды разных объектов могут совпасть. 
Здесь главное понять, что:
•	Если хеш-коды разные, то и входные объекты гарантированно разные.
•	Если хеш-коды равны, то входные объекты не всегда равны.
Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.
Создавая пользовательский класс, нужно переопределять методы hashCode() и equals(), что бы они корректно работали и учитывали данные объекта. Кроме того, если оставить реализацию из Object, то при использовании java.util.HashMap возникнут проблемы, поскольку HashMap активно используют hashCode() и equals() в своей работе

- для одного и того-же объекта, хеш-код всегда будет одинаковым;
- если объекты одинаковые, то и хеш-коды одинаковые (но не наоборот, см. правило 3)
- если хеш-коды равны, то входные объекты не всегда равны (коллизия); 
- если хеш-коды разные, то и объекты гарантированно разные;

При вычислении хэш-кода для объектов класса Object по умолчанию используется Park-Miller RNG алгоритм. В основу работы данного алгоритма положен генератор случайных чисел. Это означает, что при каждом запуске программы у объекта будет разный хэш-код.

Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)
Рефлексивность: Для всех ненулевых ссылок, a.equals(a)
Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c)
Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode()



=====================
= Garbage collector =
=====================
Сборщик мусора автоматически удаляет объект, когда на него не остается ссылок. Нельзя самому указать, какой объект удалить.

# Метод finalize().
Чтобы добавить в класс средство выполнения финализации, достаточно определить метод finalize(). Среда времени выполнения Java вызывает этот метод непосредственно перед удалением объекта данного класса. Внутри метода finalize() нужно указать те действия, которые должны быть выполнены перед уничтожением объекта. Сборщик мусора запускается периодически, проверяя наличие объектов, на которые отсутствуют ссылки как со стороны какого-либо текущего состояния, так и косвенные ссылки через другие ссылочные объекты. Непосредственно перед освобождением ресурсов среда времени выполнения Java вызывает метод finalize() по отношению к объекту.

1. Ваши объекты могут быть и не переданы сборщику мусора.
2. Сборка мусора не является удалением.
3. Процесс сборки мусора относится только к памяти.

Не нужно полагаться на вызов метода finalize() - создавайте тдельные "функции очистки" и вызывайте их явно.
Принудительная сборка мусора и финализация: System.gc();




======================================
= Overloading and overriding methods =
======================================
Перегрузка метода – определение нескольких методов с одинаковым именем метода, но разным количеством или типом входных параметров. Перегрузить метод можно создав метод с таким же именем, но другим количеством или типом параметров.
При переопределении входные параметры должны быть одинаковы, методы переопределяются только в подклассах (переопределение родительского метода). 

В переопределенном методе можно:
1. Вообще не описывать исключения – не использовать throws. Тогда код, который будет работать с родительским типом – будет требовать обработки исключения. Код, который работает с дочерним типом – нет.
2. Описать то же исключение, что и в родительском методе. Это очевидный вариант, и в комментариях вряд ли нуждается.
3. Описать любое дочернее исключение по отношению к тому, которое бросается в родительском методе. Логика тут та же, что и в случае с сужением типа возвращаемого значения. Если код обрабатывает родительский тип исключения – он поймает и все дочерние. А тот код, который будет работать с дочерним типом – он может ловить именно то, что бросается в действительности. При грамотном использовании этой возможности код может стать гораздо более читаемым.

Вызовы из конструктора методов, которые возможно переопределить, потенциально опасны тем, что они вызываются в тот момент, когда объект еще не инициализирован до конца – не отработал код дочернего конструктора.

Раннее связывание выполняется для того, чтобы определить, какой именно метод надо вызывать, исходя из имени и набора его параметров. Иначе говоря, на этом этапе компилятор разбирается с перегрузкой.
Позднее связывание служит для того, чтобы разобраться с переопределением. Зная сигнатуру метода, виртуальная машина анализирует объект, на котором этот метод вызывается, чтобы определить, в каком именно классе брать определение вызываемого метода.



================
= Arrays       =
================
http://skipy.ru/technics/arrays.html
Большая часть из того, что сказано о массивах примитивных типов, верна и для массивов объектов. Их размер может быть получен через .length, выход за границы контролируется. Создаются они через оператор new:
// array of java.awt.Point with 10 elements:
java.awt.Point[] points = new java.awt.Point[10];
Заметьте, вызова конструктора тут НЕТ. java.awt.Point после оператора new указывает лишь на тип элементов создаваемого массива.

После создания массив точно так же инициализируется значением по умолчанию... И вот тут есть большой подводный камень. Вопрос на засыпку. А каково это значение по умолчанию? Объект, созданный вызовом конструктора без параметров? А если такого конструктора нет? Ответ кроется в ответе на другой вопрос: а что, собственно, хранится в этом массиве?

А хранятся в этом массиве не объекты. Там хранятся ссылки на них. Как любая переменная объектного типа является ссылкой на объект, так и любой элемент массива тоже является ссылкой. А для ссылки значение по умолчанию – null!

Эта ошибка чуть ли не классическая. Очень часто приходится встречать вопросы "откуда тут берется NullPointerException" по отношению к коду следующего вида:

java.awt.Point[] points = new java.awt.Point[10];
points[0].x = 1; // <-- here is a NullPointerException
Теперь, думаю, понятно, откуда берется эта ошибка. Массив создан и его элементы инициализированы значением null. Однако сами объекты не созданы. Ситуация в точности аналогична использованию переменной со значением null. Правильный фрагмент выглядит так:

java.awt.Point[] points = new java.awt.Point[10];
for(int i=0; i<points.length; i++){
    points[i] = new java.awt.Point();
}
// now you can use array
points[0].x = 1; // <-- NO NullPointerException here!


========================
= Модификаторы доступа =
========================
* private – "моё и только моё". К полям, методам и классам, объявленным private, имеет доступ только класс, в котором они объявлены. Для обозначения этого уровня используется ключевое слово private.
* package – "моё и соседское". К полям, методам и классам, объявленным package, имеет доступ не только класс, в котором они объявлены, но и все классы, находящиеся в том же самом пакете. О том, что представляет собой пакет с точки зрения контроля доступа, речь пойдет ниже. Ключевого слова для обозначения этого уровня доступа, как я уже говорил, нет. Достаточно не указать любой другой.
* protected – "моё и всех наследников". К полям, методам и классам, объявленным protected, имеет доступ класс, в котором они объявлены, все классы, находящиеся в том же самом пакете и все классы, унаследованные от того, где сделано объявление. Для обозначения уровня доступа используется ключевое слово protected.
* public – "всем-всем-всем". К полям, методам и классам, объявленным public доступ имеет кто угодно. С этим уровнем надо обращаться с осторожностью, особенно это касается полей класса – очень легко потерять контроль над тем, кто и где модифицирует переменные. Для обозначения этого уровня доступа используется ключевое слово public.

!! Общее правило применения модификаторов доступа таково – чем больше ограничен доступ, тем лучше.