=================
= Serialization =
=================

Сериализация это процесс сохранения состояния объекта в последовательность байт; десериализация это процесс восстановления объекта, из этих байт. Java Serialization API предоставляет стандартный механизм для создания сериализуемых объектов.

Сериализация – запись объекта в поток. Нужна для передачи данных между разными слоями приложения. Используется, к примеру, когда на jsp надо использовать JavaBean. 
transient указывает на то, что данная переменная не будет сериализована, а при десериализации  ей будет присвоено значение null или 0, если тип базовый.

Существуют 2 способа сериализации. Первый - реализация java.io.Serializable, не требующая никаких усилий. Второй способ – это тоже реализация интерфейса, но уже другого: java.io.Externalizable. В отличие от java.io.Serializable, он содержит два метода, которые необходимо реализовать – writeExternal(ObjectOutput) и readExternal(ObjectInput). В этих методах как раз и находится логика сериализации/десериализации.
Между упомянутыми двумя способами сериализации существует еще одно серьезное отличие. А именно – в механизме десериализации. При использовании Serializable десериализация происходит так: под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается.

То есть при десериализации вызывается конструктор без параметров родительского НЕсериализуемого класса. И если такого конструктора не будет – при десериализации возникнет ошибка. Конструктор же дочернего объекта, того, который мы десериализуем, не вызывается, как и было сказано выше.

Так ведут себя стандартные механизмы при использовании Serializable. При использовании же Externalizable ситуация иная. Сначала вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal, который и вычитывает, собственно, все свои данные. Потому – любой реализующий интерфейс Externalizable класс обязан иметь public конструктор без параметров! Более того, поскольку все наследники такого класса тоже будут считаться реализующими интерфейс Externalizable, у них тоже должен быть конструктор без параметров!
Последний момент – наследование. При наследовании от класса, реализующего Serializable, никаких дополнительных действий предпринимать не надо. Сериализация будет распространяться и на дочерний класс. При наследовании от класса, реализующего Externalizable, необходимо переопределить методы родительского класса readExternal и writeExternal. Иначе поля дочернего класса сериализованы не будут. В этом случае надо бы не забыть вызвать родительские методы, иначе не сериализованы будут уже родительские поля.

Правило 1. После десериализации объекта необходимо проверить его внутреннее состояние (инварианты) на правильность, точно так же, как и при создании с помощью конструктора. Если объект не прошел такую проверку, необходимо инициировать исключение java.io.InvalidObjectException.
Правило 2. Если в составе класса A присутствуют объекты, которые не должны быть доступными для изменения извне, то при десериализации экземпляра класса A необходимо вместо этих объектов создать и сохранить их копии.



===================
= RMI             =
===================
RMI (Remote Method Invocation) — программный интерфейс вызова удаленных методов в языке Java.

Распределенная объектная модель, специфицирующая, каким образом производится вызов удаленных методов, работающих на другой виртуальной машине Java.
При доступе к объектам на другом компьютере возможно вызывать методы этого объекта. Необходимо только передать параметры метода на другой компьютер, сообщить объекту о необходимости выполнения метода, а затем получить обратно возвращаемое значение. Механизм RMI дает возможность организовать выполнение всех этих операций.
Типичная реализация модели Java-RMI, использующая объекты 'заглушки'(stub) и 'скелета'(skeleton).
В терминах RMI объект, который вызывает удаленный метод, называется клиентским объектом, а удаленный объект — серверным объектом. Компьютеры выступают в роли клиента и сервера только для конкретного вызова. Вполне возможно, что при выполнении следующей операции эти компьютеры поменяются ролями, то есть сервер предыдущего вызова может сам стать клиентом при обращении к объекту на другом компьютере.
При вызове метода удаленного объекта на самом деле вызывается обычный метод языка Java, инкапсулированный в специальном объекте-заглушке (stub), который является представителем серверного объекта. Заглушка находится на клиентском компьютере, а не на сервере. Она упаковывает параметры удаленного метода в блок байтов. Каждый параметр кодируется с помощью алгоритма, обеспечивающего независимость от аппаратуры. Например, числа всегда передаются в порядке, при котором сначала передается старший байт (big-endian). При этом объекты подвергаются сериализации. Процесс кодирования параметров называется развертыванием параметров (parameter marshaling). Основная цель развертывания параметров — преобразование их в формат, пригодный для передачи параметров от одной виртуальной машины к другой.



===================================
=  EXCEPTIONS                     =
===================================
— Throwable и Exception и все их наследники (за исключением наследников Error-а и RuntimeException-а) — checked
— Error и RuntimeException и все их наследники — unchecked

                    Object
                      |
                  Throwable
                  /      \
              Error     Exception
                            |
                    RuntimeException

Необходимо понимать, что 
— проверка на cheched исключения происходит в момент компиляции (compile-time checking)
— перехват исключений (catch) происходит в момент выполнения (runtime checking)

Все классы обрабатывающие ошибки являются наследниками класса java.lang.Throwable. Только объекты этого класса или его наследников могут быть "брошены" JVM при возникновении какой-нибудь исключительной ситуации, а также только эти объекты могут быть "брошены" во время выполнения программы с помощью ключевого слова throw.
Прямыми наследниками класса Throwable являются Error и Exception.

Error - это подкласс, который показывает серьезные проблемы возникающие во время выполнения приложения. Большинство из этих ошибок сигнализируют о ненормальном ходе выполнения программы, т.е. о каких-то критических проблемах. Эти ошибки не рекомендуется отмечать в методах посредством throws-объявления, поэтому они также очень часто называются непроверяемые (unchecked). Примерами таких исключений являются: ThreadDeath, VirtualMachineError, OutOfMemoryError.

Exception - это подкласс исключений, которые приложение может "выбрасывать" во время своей работы и которые должны быть обработаны в тех методах, где они возникают, или "проброшены" дальше, для обработки на более позднем этапе. Это обычно проверяемые (checked) исключения. Примерами являются: ClassNotFoundException, IOException.

У класса Exception есть один подкласс, который не рекомендуется декларировать в методах с помощью throws. Это RuntimeException и все его наследники. Исключения этого типа возникают во время выполнения программы. Поскольку они могут возникнуть в любом методе, то пришлось бы декларировать их везде, что существенно усложнило бы жизнь разработчикам. Вместо этого рекомендуется в коде программы делать необходимые проверки, чтоб избежать возникновения этих исключений. IndexOutOfBoundsException, IllegalArgumentException, NullPointerException.

Cвойством транзакционности исключения не обладают – действия, произведенные в блоке try до возникновения исключения, не отменяются поcле его возникновения.

При написании бизнес-логики – в особенности это касается библиотек – часто бывает полезным создать собственный тип исключения. Просто для того, чтобы дать возможность обрабатывать ваши исключения отдельно от остальных. Иехрархия исключений JDK не может предусмотреть все возможные ошибки, поэтому вы вправе создавать собственные типы исключений для обозначения специфических ошибок вашей программы.

- создается объект, представляющий исключение;
- текущий поток останавливается, и ссылка на объект, представляющий исключение, извлечкается из текущего контекста;
- включается механизм обработки исключений, который начинает поиск подходящего места программы для передачи исключения;
- таким местом является обработчик исключений, который пытается решить возникшую проблему так, чтобы программа могла снова попытаться выполнить проблемную операцию или просто продолжила свое выполнение.

"Обмануть" компилятор все же можно: вы вправе объявить о возбуждении исключения, которого на самом деле нет. Компилятор верит вам на слово и заставляет пользователей метода поступать так, как будто им и в самом деле необходимо перехватывать исключение. Таким образом можно "зарезервировать" исключение на будущее и уже потом возбуждать его, не изменяя описания готовой программы.

Выполнение finally можно избежать например при системном выходе из программы в блоке try: System.exit(0);



===================
= XML             =
===================
Well-formed документ должен соответствовать синтаксису xml.
Valid, в отличие от well-formed, должен соответствовать  схеме.

XML - это документ с тегами, оформленный по жестким правилам синтаксической корректности.
	- XML-документ имеет ровно один корневой элемент, в котором лежат все остальные. То есть, <document>...</document><appendix>...</appendix> - это не XML-документ.
	- Все открытые теги обязаны быть закрыты.
	- Для одиночных тегов (типа <br>) , чтобы отличать их от открывающих, предусмотрена специальная запись: <br/>. Но можно, кстати, написать и полностью <br></br>
	- Имена тегов регистрозависимые.
	- Теги не могут нарушать вложенность. Вот такого не должно быть: <em><b>...</em></b>.
	- Все атрибуты тегов обязаны быть заключены в двойные кавычки (").
	- Есть три символа - <, > и &, которые обязаны быть экранированы везде с помощью &lt;, &gt; и &amp;. А внутри атрибутов надо экранировать еще и двойную кавычку с помощью &quot;.
	- Все символы в документе обязаны соответствовать заявленной кодировке.

В языках с тегами правила валидности определяют такие вещи:
	- Название корневого элемента
	- Элементы, допустимые внутри какого-то элемента
	- Допустимость текста внутри элемента
	- Обязательность присутствия элемента
	- Обязательность присутствия конкретных атрибутов элемента
	- Расшифровки строковых сущностей (типа &rarr; - это юникодный символ с кодом 8594 - стрелка вправо). Напомню, базовый синтаксис XML определяет только &lt;, &gt;, &amp; и &quot;.

DOM – создаёт полную древовидную модель xml-документа. Позволяет изменять данные в xml-документе. Применяется, когда нужно получить все данные или внести изменения.
SAX – основана на обработке событий, позволяет извлечь отдельные данные не извлекая остальные.
StAX – работает по тому же принципу, что и SAX. Отличие состоит в том, что разработчик сам указывает, когда перейти к следующему элементу.
