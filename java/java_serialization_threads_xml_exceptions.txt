=================
= Serialization =
=================

Сериализация это процесс сохранения состояния объекта в последовательность байт; десериализация это процесс восстановления объекта, из этих байт. Java Serialization API предоставляет стандартный механизм для создания сериализуемых объектов.

Сериализация – запись объекта в поток. Нужна для передачи данных между разными слоями приложения. Используется, к примеру, когда на jsp надо использовать JavaBean. 
transient указывает на то, что данная переменная не будет сериализована, а при десериализации  ей будет присвоено значение null или 0, если тип базовый.

Существуют 2 способа сериализации. Первый - реализация java.io.Serializable, не требующая никаких усилий. Второй способ – это тоже реализация интерфейса, но уже другого: java.io.Externalizable. В отличие от java.io.Serializable, он содержит два метода, которые необходимо реализовать – writeExternal(ObjectOutput) и readExternal(ObjectInput). В этих методах как раз и находится логика сериализации/десериализации.
Между упомянутыми двумя способами сериализации существует еще одно серьезное отличие. А именно – в механизме десериализации. При использовании Serializable десериализация происходит так: под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается.

То есть при десериализации вызывается конструктор без параметров родительского НЕсериализуемого класса. И если такого конструктора не будет – при десериализации возникнет ошибка. Конструктор же дочернего объекта, того, который мы десериализуем, не вызывается, как и было сказано выше.

Так ведут себя стандартные механизмы при использовании Serializable. При использовании же Externalizable ситуация иная. Сначала вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal, который и вычитывает, собственно, все свои данные. Потому – любой реализующий интерфейс Externalizable класс обязан иметь public конструктор без параметров! Более того, поскольку все наследники такого класса тоже будут считаться реализующими интерфейс Externalizable, у них тоже должен быть конструктор без параметров!
Последний момент – наследование. При наследовании от класса, реализующего Serializable, никаких дополнительных действий предпринимать не надо. Сериализация будет распространяться и на дочерний класс. При наследовании от класса, реализующего Externalizable, необходимо переопределить методы родительского класса readExternal и writeExternal. Иначе поля дочернего класса сериализованы не будут. В этом случае надо бы не забыть вызвать родительские методы, иначе не сериализованы будут уже родительские поля.

Правило 1. После десериализации объекта необходимо проверить его внутреннее состояние (инварианты) на правильность, точно так же, как и при создании с помощью конструктора. Если объект не прошел такую проверку, необходимо инициировать исключение java.io.InvalidObjectException.
Правило 2. Если в составе класса A присутствуют объекты, которые не должны быть доступными для изменения извне, то при десериализации экземпляра класса A необходимо вместо этих объектов создать и сохранить их копии.



===================
= RMI             =
===================
RMI (Remote Method Invocation) — программный интерфейс вызова удаленных методов в языке Java.

Распределенная объектная модель, специфицирующая, каким образом производится вызов удаленных методов, работающих на другой виртуальной машине Java.
При доступе к объектам на другом компьютере возможно вызывать методы этого объекта. Необходимо только передать параметры метода на другой компьютер, сообщить объекту о необходимости выполнения метода, а затем получить обратно возвращаемое значение. Механизм RMI дает возможность организовать выполнение всех этих операций.
Типичная реализация модели Java-RMI, использующая объекты 'заглушки'(stub) и 'скелета'(skeleton).
В терминах RMI объект, который вызывает удаленный метод, называется клиентским объектом, а удаленный объект — серверным объектом. Компьютеры выступают в роли клиента и сервера только для конкретного вызова. Вполне возможно, что при выполнении следующей операции эти компьютеры поменяются ролями, то есть сервер предыдущего вызова может сам стать клиентом при обращении к объекту на другом компьютере.
При вызове метода удаленного объекта на самом деле вызывается обычный метод языка Java, инкапсулированный в специальном объекте-заглушке (stub), который является представителем серверного объекта. Заглушка находится на клиентском компьютере, а не на сервере. Она упаковывает параметры удаленного метода в блок байтов. Каждый параметр кодируется с помощью алгоритма, обеспечивающего независимость от аппаратуры. Например, числа всегда передаются в порядке, при котором сначала передается старший байт (big-endian). При этом объекты подвергаются сериализации. Процесс кодирования параметров называется развертыванием параметров (parameter marshaling). Основная цель развертывания параметров — преобразование их в формат, пригодный для передачи параметров от одной виртуальной машины к другой.



===================================
=  EXCEPTIONS                     =
===================================
— Throwable и Exception и все их наследники (за исключением наследников Error-а и RuntimeException-а) — checked
— Error и RuntimeException и все их наследники — unchecked

                    Object
                      |
                  Throwable
                  /      \
              Error     Exception
                            |
                    RuntimeException

Необходимо понимать, что 
— проверка на cheched исключения происходит в момент компиляции (compile-time checking)
— перехват исключений (catch) происходит в момент выполнения (runtime checking)

Все классы обрабатывающие ошибки являются наследниками класса java.lang.Throwable. Только объекты этого класса или его наследников могут быть "брошены" JVM при возникновении какой-нибудь исключительной ситуации, а также только эти объекты могут быть "брошены" во время выполнения программы с помощью ключевого слова throw.
Прямыми наследниками класса Throwable являются Error и Exception.

Error - это подкласс, который показывает серьезные проблемы возникающие во время выполнения приложения. Большинство из этих ошибок сигнализируют о ненормальном ходе выполнения программы, т.е. о каких-то критических проблемах. Эти ошибки не рекомендуется отмечать в методах посредством throws-объявления, поэтому они также очень часто называются непроверяемые (unchecked). Примерами таких исключений являются: ThreadDeath, VirtualMachineError, OutOfMemoryError.

Exception - это подкласс исключений, которые приложение может "выбрасывать" во время своей работы и которые должны быть обработаны в тех методах, где они возникают, или "проброшены" дальше, для обработки на более позднем этапе. Это обычно проверяемые (checked) исключения. Примерами являются: ClassNotFoundException, IOException.

У класса Exception есть один подкласс, который не рекомендуется декларировать в методах с помощью throws. Это RuntimeException и все его наследники. Исключения этого типа возникают во время выполнения программы. Поскольку они могут возникнуть в любом методе, то пришлось бы декларировать их везде, что существенно усложнило бы жизнь разработчикам. Вместо этого рекомендуется в коде программы делать необходимые проверки, чтоб избежать возникновения этих исключений. IndexOutOfBoundsException, IllegalArgumentException, NullPointerException.

Cвойством транзакционности исключения не обладают – действия, произведенные в блоке try до возникновения исключения, не отменяются поcле его возникновения.

При написании бизнес-логики – в особенности это касается библиотек – часто бывает полезным создать собственный тип исключения. Просто для того, чтобы дать возможность обрабатывать ваши исключения отдельно от остальных. Иехрархия исключений JDK не может предусмотреть все возможные ошибки, поэтому вы вправе создавать собственные типы исключений для обозначения специфических ошибок вашей программы.

- создается объект, представляющий исключение;
- текущий поток останавливается, и ссылка на объект, представляющий исключение, извлечкается из текущего контекста;
- включается механизм обработки исключений, который начинает поиск подходящего места программы для передачи исключения;
- таким местом является обработчик исключений, который пытается решить возникшую проблему так, чтобы программа могла снова попытаться выполнить проблемную операцию или просто продолжила свое выполнение.

"Обмануть" компилятор все же можно: вы вправе объявить о возбуждении исключения, которого на самом деле нет. Компилятор верит вам на слово и заставляет пользователей метода поступать так, как будто им и в самом деле необходимо перехватывать исключение. Таким образом можно "зарезервировать" исключение на будущее и уже потом возбуждать его, не изменяя описания готовой программы.

Выполнение finally можно избежать например при системном выходе из программы в блоке try: System.exit(0); Блок finally также исполняется при использовании команд break и continue. Заметьте, что комбинация finally в сочетании с break и continue с метками снимает в Java всякую необходимость в операторе goto. Выполнение finally не зависит от того, в какой точке защищенной секции была выполнена команда return. Команда 'return' в блоке finally прерывает обработку исключения.

Если расположить блок try в цикле, можно также определить условие, на основании которого будет решено, должна ли программа продолжаться. Так-же можно добавить статический счетчик или иной механизм для проверки нескольких разных решений, прежде чем отказаться от попыток восстановления. Это один из способов обеспечения повышенной отказзоустойчивости программ.

Способы обхода проверяемых исключений:
- Передача исключений на консоль (объявляем в методе throws)
- Преобразование проверяемого исключения в RuntimeException (в catch: throw new RuntimeException)

Основные правила обработки исключений (используйте исключения для того, чтобы):
- обработать ошибку на текущем уровне (избегайте перехватывать исключения, если вы не знаете, как с ними поступить);
- исправить проблему и снова вызвать метод, возбудивший исключение;
- предпринять все необходимые действия и продолжить выполнение без повторного вызова метода;
- попытаться найти альтернативный результат вместо того, котлорый должен был бы произвести вызванный метод;
- сделать все возможное в текущем контексте и заново возбудеть это же исключение, перенаправив его на более высокий уровень;
- сделать все, что можно в текущем контексте, и возбудить новое исключение, перенаправив его на более высокий уровень;
- завершить работу программы;
- упростить программу (если используемая вами схема обработки исключений делает все только сложнее, значит, она никуда не годится);
- добавить вашей библиотеке и программе безопасности (сначала это поможет в отладке программы, а в дальнейшем окупится ее надежностью).



===================
= XML             =
===================
Well-formed документ должен соответствовать синтаксису xml.
Valid, в отличие от well-formed, должен соответствовать  схеме.

XML - это документ с тегами, оформленный по жестким правилам синтаксической корректности.
	- XML-документ имеет ровно один корневой элемент, в котором лежат все остальные. То есть, <document>...</document><appendix>...</appendix> - это не XML-документ.
	- Все открытые теги обязаны быть закрыты.
	- Для одиночных тегов (типа <br>) , чтобы отличать их от открывающих, предусмотрена специальная запись: <br/>. Но можно, кстати, написать и полностью <br></br>
	- Имена тегов регистрозависимые.
	- Теги не могут нарушать вложенность. Вот такого не должно быть: <em><b>...</em></b>.
	- Все атрибуты тегов обязаны быть заключены в двойные кавычки (").
	- Есть три символа - <, > и &, которые обязаны быть экранированы везде с помощью &lt;, &gt; и &amp;. А внутри атрибутов надо экранировать еще и двойную кавычку с помощью &quot;.
	- Все символы в документе обязаны соответствовать заявленной кодировке.

В языках с тегами правила валидности определяют такие вещи:
	- Название корневого элемента
	- Элементы, допустимые внутри какого-то элемента
	- Допустимость текста внутри элемента
	- Обязательность присутствия элемента
	- Обязательность присутствия конкретных атрибутов элемента
	- Расшифровки строковых сущностей (типа &rarr; - это юникодный символ с кодом 8594 - стрелка вправо). Напомню, базовый синтаксис XML определяет только &lt;, &gt;, &amp; и &quot;.

DOM – создаёт полную древовидную модель xml-документа. Позволяет изменять данные в xml-документе. Применяется, когда нужно получить все данные или внести изменения.
SAX – основана на обработке событий, позволяет извлечь отдельные данные не извлекая остальные.
StAX – работает по тому же принципу, что и SAX. Отличие состоит в том, что разработчик сам указывает, когда перейти к следующему элементу.



========================
= MULTITHREADING       =
========================
# Когда поток переходит из нового состояния в работоспособное?
Когда вызывается метод start(), поток переходит из нового состояния в работоспособное.
 Как заставить главный поток ждать завершения побочного?
Чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.
Поток – часть процесса, состоящий из набора команд и имеющий одно адресное пространство. 
Поток создаётся наследованием класса Thread или реализацией интерфейса Runnable.
Запускается поток методом start(), который запускает метод  run(). Если поток был приостановлен, то запустить снова его можно методами notify() и notifyAll(), который запускает все приостановленные потоки. 
Остановить поток можно методом interrupt(). Приостановить его можно методом wait().
Состояния потока: новый, работоспособный, работающий, ожидающий, заблокированный, спящий, мёртвый. 

Поток создаётся либо наследованием от Thread, либо реализацией Runnable.

В Java существуют (существовали) средства для принудительного завершения потока. В частности метод Thread.stop() завершает поток незамедлительно после своего выполнения. Однако этот метод, а также Thread.suspend(), приостанавливающий поток, и Thread.resume(), продолжающий выполнение потока, были объявлены устаревшими и их использование отныне крайне нежелательно. Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке.

# Что такое синхронизация? Что такое deadlock? Какие методы синхронизации вы знаете? Для чего нужно ключевое слово synchronized? Для чего применяется ключевое слово volatile?
Синхронизация – обеспечение безопасного взаимодействия нескольких потоков с одним и тем же ресурсом.
deadlock – взаимная блокировка – ситуация, когда один поток взаимодействует с первым ресурсом, блокирует его, и пытается обратиться к другому ресурсу, который используется другим потоком, также блокирующим его. Причём  второй поток пытается обратиться к первому ресурсу. Таким образом, первый поток ждёт освобождения второго ресурса, а второй поток – первого ресурса.
Методы синхронизации: synchronized (синхронизировать метод, синхронизировать блок), использовать concurrent, использовать lock.
synchronized используется, чтобы указать, что данный метод или блок синхронизирован.
volatile используется для того, чтобы объявить переменную, изменения которой в одном потоке будут видны во всех.

Хочу еще разграничить два понятия – поток и процесс. Процесс – это задача операционной системы. У него собственное адресное пространство. С ним может быть проассоциировано несколько потоков. Поток же – это гораздо более мелкая единица. Все потоки разделяют адресное пространство породившего их процесса и имеют доступ к одним данным.
Существует два пути создания потока. Первый – наследование от класса java.lang.Thread и переопределение его метода run. Второй – реализация интерфейса java.lang.Runnable и создание потока на основе этой реализации. В принципе это методы эквивалентны, разница в деталях. Наследование от java.lang.Thread делает его единственным родителем класса, что не всегда удобно. Я лично предпочитаю реализовывать java.lang.Runnable.
В приведенных примерах в методах main создаются потоки, после чего они запускаются на выполнение. Поток завершается, когда произошел выход из метода run, либо если в методе run было выброшено исключение, которое не было обработано. Чаще всего это RuntimeException или наследник, реже – Error или наследник. После того, как поток завершил работу, перестартовать его НЕЛЬЗЯ. Попытка вторичного вызова start приведет к исключению IllegalThreadStateException.

Для того, чтобы уже закончить с классом Thread, коснемся еще нескольких его возможностей.
- Во-первых, у потоков могут быть различные приоритеты. Существует несколько констант – Thread.MIN_PRIORITY == 1, Thread.NORM_PRIORITY == 5 и Thread.MAX_PRIORITY == 10. Значения эти внутренние и с реальными приоритетами потоков в операционной системе соотносятся слабо.
- Во-вторых, потоки могу быть т.н. демонами. Такой поток отличается от обычного тем, что он не препятствует окончанию работы виртуальной машины. Т.е. можно сказать, что виртуальная машина работает, пока существует хотя бы один поток, не являющийся демоном. Потоки-демоны удобно использовать для фоновых задач.
- В-третьих, поток можно приостановить на определенный промежуток времени. Изнутри. Делается это через статический метод Thread.sleep() с параметром – количеством миллисекунд, на которое приостанавливается поток. До истечения этого времени поток может быть выведен из состояния ожидания вызовом interrupt, о котором мы поговорим в следующей части.
- И последнее, чего бы я тут хотел коснуться – статический метод yield. Он служит для передачи управления другим потокам. Т.е. в результате его вызова происходит переключение контекста и процессор начинает исполнять код другого потока. Это нужно как в ситуациях, когда работа на текущий момент завершена и можно дать поработать другим (например, поток обрабатывает данные, все обработал, а новые еще не пришли), так и в ситуациях, когда поток занимается какими-нибудь интенсивными действиями, съедает большую часть процессора и не дает другим потокам работать. Правда, последний подход я встречал только в программировании под Java ME, в условиях ограниченных ресурсов. Обратите внимание, что этот метод статический и действует только на текущий поток. Заставить таким образом чужой поток поделиться своим временем нельзя!

На данный момент мы знаем, как запустить поток на выполнение. Естественный вопрос – а как его остановить? Ответ может оказаться обескураживающим. В Java НЕТ средств для принудительной остановки потока. Вернее, они есть, но использовать их не стоит – метод stop объявлен deprecated. А вместе с ним – и suspend c resume.
Почему это так сделано? Причины, несомненно, есть. Дело в том, что при принудительной остановке (приостановке) потока совершенно непонятно, что делать с ресурсами. Поток может открыть сетевое соединение, например. Что делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? То же самое и про соединение с базой данных. И еще много про что. А если поток остановят посередине транзакции? Кто ее будет закрывать? Кто будет разблокировать ресурсы? В общем, проблем тут существенно больше, чем преимуществ.
Потому – в Java принят уведомительный порядок остановки потока. Вариантов реализации два: либо воспользоваться существующими механизмами, либо создавать такие механизмы вручную. Мы рассмотрим оба варианта и проблемы, связаные с ними.

Вариант первый – использовать существующий механизм. У класса Thread есть такой метод – interrupt. Этот метод выставляет некоторый флаг в дебрях native-кода. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted. Существует также статический метод interrupted, который производит проверку для текущего потока. Обратите внимание – вызов этого метода сбрасывает флаг, что подразумевает ответственность разработчика по обработке этой ситуации.
Что хорошо в методе interrupt? Он способен вывести поток из состояния ожидания. Т.е. если у потока были вызваны методы sleep или wait (мы поговорим о нем ниже) – ожидание прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется, т.к. на брошеное исключение разработчик отреагирует незамедлительно.
Таким образом, действовать нужно так. Реализуете поток (удобнее через наследование от Thread). В потоке периодически вставляете проверки isInterrupted. Если проверка сработала или выброшено исключение во время ожидания – поток пытаются остановить извне. Обращаю внимание – именно остановить, а не ПРИостановить. Вам надо принять решение – либо вы продолжаете работу (если по каким-то причинам не можете остановиться), либо вы освобождаете ресурсы и выходите из метода run. Что вы выберете – зависит от ситуации. Главное – у вас есть возможность маневрировать и делать то, что сочтете нужным. В том числе и продолжать работу. В случае вызова stop такой возможности нет.

Любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (на который он может сослаться как на this). Если это удалось – метод исполняется. Если нет – поток останавливается и ждет, пока монитор будет отпущен.

Итак, резюме. Если два нестатических метода объявлены как synchronized, то в каждый момент времени из разных потоков на одном объекте может быть вызван только один из них. Поток, который вызывает метод первым, захватит монитор, и второму потоку придется ждать. Заостряю ваше внимание на трех моментах:
- Это верно только для разных потоков. Один и тот же поток может вызвать синхронизированный метод, внутри него – другой синхронизированный метод на том же экземпляре. Поскольку этот поток владеет монитором, проблем второй вызов не создаст.
- Это верно только для вызовов методов одного экземпляра. У разных экземпляров разные мониторы, потому одновременный вызов нестатических методов проблем не создаст
- В случае статических методов имеет значение только одно – разные ли потоки, вызывающие синхронизированные методы, или нет. Об экземпляре тут речи не идет, его роль исполняет объект класса.

Методы wait(), wait(long mills), wait(long mills, int nanos), notify()n notifyAll() можно вызывать только внутри synchronized-метода или блока. Вызываются на объекте this в методе, или на объекте по которому мы синхронизируемся в блоке. Иначе методы кинут исключение.



