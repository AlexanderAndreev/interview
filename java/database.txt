Атомарность означает выполнение операции целиком непрерывно (либо невыполнение ее вовсе).
	В Java атомарными являются операции чтения/записи всех примитивных типов данных за исключением типов long и double, поскольку эти типы данных занимают два машинных слова, их операции чтения/записи являются составными операциями из двух атомарных операций над старшими и младшими битами числа соответственно.
	Однако операции над volatile long и volatile double атомарны.
	Операции над ссылками на объекты в Java являются всегда атомарными независимо от разрядности JVM и гарантируются JMM.


Приниципы ACID:
Atomicity — Атомарность - Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние — со стороны будет казаться, что транзакции и не было. (Естественно, счётчики, индексы и другие внутренние структуры могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.)
	
Consistency — Согласованность - Транзакция достигающая своего нормального завершения (EOT – end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвертого свойства.Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисление, то система останется в некорректном состоянии и свойство согласованности будет нарушено.Наконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего,двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции, никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.
	 
Isolation — Изолированность - Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат. Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности Repeatable Read и ниже).

	Durability — Надежность - Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой 
транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может 
быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.


# Транзакции, что такое, для чего используются? Уровни изолированности транзакций. Привести примеры использования.
	Транзакция – несколько операций, выполняемых как одна, либо не выполняемые совсем.
	Используется для запросов к БД, исключающих потерю данных и некорректное взаимодействие с БД. Смысл в том, что если происходит ошибка на этапе выполнения одной из операций, то результат всех операций будет отменён.
	Уровни изолированности:
		Serializable – исключаются все виды ошибок.
		Repeatable read – исключаются все виды ошибок, кроме фантомного чтения.
		Read committed – исключается потеря обновления и грязное чтение. 
		Read uncommitted – исключается только потеря обновлений.
		Пример использования – банковская система: снятие денег со счёта и выдача их клиенту должна проходить как единое действие, поэтому используется транзакция. 



	SQL, запросы, join  и тд.
	inner join - INNER JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах.
	left outer join - JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах + строки которые присутствуют только в левой колонке.
	right outer join -  JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах + строки которые присутствуют только в правой колонке.
	
	INSERT INTO table1 (username) VALUES ('foo'); 
	UPDATE table2 SET user_id='2', phone_number='200' WHERE phone_id='1';
	DELETE FROM table1 WHERE user_id = 1; 
	RENAME TABLE table1 TO nya;
	ALTER TABLE lcssm.application ADD CONSTRAINT uk_application_application_number UNIQUE (application_number);
	ALTER TABLE lcssm.application DROP CONSTRAINT uk_application_application_number;
	ALTER TABLE lcssm.application ADD CONSTRAINT chk_application_additional_info CHECK (additional_info <> '');
	ALTER TABLE lcssm.documents ALTER date DROP NOT NULL;
	ALTER TABLE lcssm.documents ALTER date SET NOT NULL;
	alter table lcssm.houses add column change_date bigint NOT NULL;
	alter table lcssm.houses drop column change_date;
	update lcssm.licenses set original_license_guid = null where version_number = 1;	
	group by групирует по строке, а having используется только вместе с group by и слежит для фильтрации по колонкам в group by.



# Как сделать запросы к базе данных через jdbc.  Перечислите все этапы. Чем отличается Statement от PreparedStatement? Где сохраняется запрос после первого вызова PreparedStatement? Зачем нужен CallableStatement?
 	Создаётся соединение (либо берётся из пула), создаётся запрос (либо подготавливается), выполняется запрос.
	PreparedStatement не допускает инъекций и при большом количестве запросов, отличающихся только параметрами, даёт лучшую производительность. После первого вызова PreparedStatement сохраняется в кэше СУБД. Обратно возвращается его id и количество параметров. При его выполнении драйвер передаёт в СУБД только id и параметры, а СУБД находит соответствующий запрос, подставляет параметры и выполняет его.  При последующих вызовах этого prepared, СУБД просто находит уже созданный запрос и возвращает его id.
	CallableStatement нужен для вызова хранимых процедур.





	