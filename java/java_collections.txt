=================
= COMMON        =
=================
- Базовый контейнер ArrayList, оптимизированный для произвольного доступа к элементам, но с относительно медленными операциями вставки (удаление) элементов в середине списка.
- Контейнер LinkedList, оптимизированный для последовательного доступа, с быстрыми операциями вставки (удаления) в середине списка. Произвольный доступ к элементам LinkedList выполняется относительно медленно, но по широте возможностей он превосходит ArrayList. 
Используйте ArrayList при частом использовании произвольного доступа к элементам или LinkedList при частом выполнении операций вставки и удаления в середине списка.

Методы класса Vector синхронизированы, в то время как ArrayList - нет.
HashSet - внутри использует HashMap. Плюсы в постоянном доступе таких методов как add(), contain(), remove(), size().
TreeSet (элементы по возрастанию) - внутри использует TreeMap.
LinkedHashSet (элементы хранятся в порядке добавления)

Set от List отличается тем, что в Set могут содержаться только уникальные объекты.  
Queue и Deque характеризуются тем, что элементы извлекаются в том же порядке, в котором ложатся (FIFO).
ArrayList обеспечивает наилучшее быстродействие, когда требуется часто извлекать произвольные объекты.
LinkedList - когда требуется много добавлять и удалять произвольные объекты.
HashTable, в отличие от HashMap, потокобезопасный, но более медленный. Однако, применять HashTable не стоит никогда, так как для многопоточности существует более новый и совершенный  ConcurrentHashTable.  Кроме неё, в пакете concurrent есть полезная коллекция ArrayBlockingQueue, которая представляет собой  упорядоченную блокирующую очередь, ей удобно применять для пулов соединений с БД




=================
=  ARRAYLIST    =
=================
Преимущества перед обычным массивом: расширяемость/уменьшаемость. Нет необходимости указывать размерность изначально (по-умолчанию размер будет равным 10).
Только что созданный объект list, содержит свойства elementData и size. Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов типа Object (с приведением к типу, разумеется).

Добавление в конец списка. Внутри метода add(value) происходят следующие вещи:
1) проверяется, достаточно ли места в массиве для вставки нового элемента;
	ensureCapacity(size + 1);
2) добавляется элемент в конец (согласно значению size) массива.
	elementData[size++] = element;

Добавление в «середину» списка (list.add(5, "100");)
1) проверяется, достаточно ли места в массиве для вставки нового элемента;
	ensureCapacity(size + 1);
2) подготавливается место для нового элемента с помощью System.arraycopy();
	System.arraycopy(elementData, index, elementData, index + 1, size - index);
3) перезаписывается значение у элемента с указанным индексом.
	elementData[index] = element;
	size++;

Удалять элементы можно двумя способами:
— по индексу remove(index)
— по значению remove(value)

С удалением элемента по индексу всё достаточно просто
	list.remove(5);
Сначала определяется какое количество элементов надо скопировать
	int numMoved = size - index - 1;
затем копируем элементы используя System.arraycopy()
	System.arraycopy(elementData, index + 1, elementData, index, numMoved);
уменьшаем размер массива и забываем про последний элемент
	elementData[--size] = null; // Let gc do its work
При удалении по значению, в цикле просматриваются все элементы списка, до тех пор пока не будет найдено соответствие. Удален будет лишь первый найденный элемент. При удалении элементов текущая величина capacity не уменьшается, что может привести к своеобразным утечкам памяти. Поэтому не стоит пренебрегать методом trimToSize().

ArrayList - когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных мест, то вызов System.arraycopy() случится дважды: первый в ensureCapacity(), второй в самом методе add(index, value), что явно скажется на скорости всей операции добавления. В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать метод addAll(index, Collection). И хотя, данный метод скорее всего вызовет System.arraycopy() три раза, в итоге это будет гораздо быстрее поэлементного добавления.
	— Быстрый доступ к элементам по индексу за время O(1);
	— Доступ к элементам по значению за линейное время O(n);
	— Медленный, когда вставляются и удаляются элементы из «середины» списка;
	— Позволяет хранить любые значения в том числе и null;
	— Не синхронизирован.




==============
= LINKEDLIST =
==============
Реализует интерфейс List. Является представителем двунаправленного списка, где каждый элемент структуры содержит указатели на предыдущий и следующий элементы. Итератор поддерживает обход в обе стороны. Реализует методы получения, удаления и вставки в начало, середину и конец списка. Позволяет добавлять любые элементы, в том числе и null.

Только что созданный объект list, содержит свойства header и size.
header — псевдо-элемент списка. Его значение всегда равно null, a свойства next и prev всегда указывают на первый и последний элемент списка соответственно. Так как на данный момент список еще пуст, свойства next и prev указывают сами на себя (т.е. на элемент header). Размер списка size равен 0.
	header.next = header.prev = header;

Добавление элемента в конец списка с помощью методом add(value), addLast(value) и добавление в начало списка с помощью addFirst(value) выполняется за время O(1).
Каждый раз при добавлении нового элемента, по сути выполняется два шага:
1) создается новый новый экземпляр класса Entry
	Node newNode = new Node(header, "0", header.prev);
2) переопределяются указатели на предыдущий и следующий элемент
	newNode.prev.next = newNode;
	newNode.next.prev = newNode;
	size++;

Удалять элементы из списка можно несколькими способами:
— из начала или конца списка с помощью removeFirst(), removeLast() за время O(1);
— по индексу remove(index) и по значению remove(value) за время O(n).

	— Из LinkedList можно организовать стэк, очередь, или двойную очередь, со временем доступа O(1);
	— На вставку и удаление из середины списка, получение элемента по индексу или значению потребуется линейное время O(n). Однако, на добавление и удаление из середины списка, используя ListIterator.add() и ListIterator.remove(), потребуется O(1);
	— Позволяет добавлять любые значения в том числе и null. Для хранения примитивных типов использует соответствующие классы-оберки;
	— Не синхронизирован.




==============
= SET        =
==============
Множества часто испльзуются для проверки принадлежности, чтобы вы могли легко проверить, принадлжеит ли объект заданному множеству. Следовательно, важнейшей операцией Set является операция поиска, поэтому на практике обычно выбирается реализация HashSet, оптимизированная для быстрого поиска. При необходимости сортировки результата нужно использовать TreeSet. 




==============
= MAP        =
==============

# HASHMAP
HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не дает гарантий относительно порядка элементов с течением времени. Разрешение коллизий осуществляется с помощью метода цепочек.

1.	Сначала ключ проверяется на равенство null. Если это проверка вернула true, будет вызван метод putForNullKey(value) (вариант с добавлением null-ключа рассмотрим чуть позже).
2.	Далее генерируется хэш на основе ключа. Для генерации используется метод hash(hashCode), в который передается key.hashCode().
3.	С помощью метода indexFor(hash, tableLength), определяется позиция в массиве, куда будет помещен элемент.
4.	Теперь, зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается.
5.	Если же предыдущий шаг не выявил совпадений, будет вызван метод addEntry(hash, key, value, index) для добавления нового элемента.

    — Добавление элемента выполняется за время O(1), потому как новые элементы вставляются в начало цепочки;
	— Операции получения и удаления элемента могут выполняться за время O(1), если хэш-функция равномерно распределяет элементы и отсутствуют коллизии. Среднее же время работы будет ?(1 + ?), где ? — коэффициент загрузки. В самом худшем случае, время выполнения может составить ?(n) (все элементы в одной цепочке);
	— Ключи и значения могут быть любых типов, в том числе и null. Для хранения примитивных типов используются соответствующие классы-оберки;
	— Не синхронизирован.
	В каждой цепочке хранятся значения, которые имеют ссылку на next элемент.


# LINKEDHASHMAP
Данная структура может слегка уступать по производительности родительскому HashMap, при этом время выполнения операций add(), contains(), remove() остается константой — O(1). Понадобится чуть больше места в памяти для хранения элементов и их связей, но это совсем небольшая плата за дополнительные фишечки.
Вообще, из-за того что всю основную работу на себя берет родительский класс, серьезных отличий в реализации HashMap и LinkedHashMap не много. Можно упомянуть о парочке мелких:
	- Методы transfer() и containsValue() устроены чуть проще из-за наличия двунаправленной связи между элементами;
	- В классе LinkedHashMap.Entry реализованы методы recordRemoval() и recordAccess() (тот самый, который помещает элемент в конец при accessOrder = true). В HashMap оба этих метода пустые.
	- В каждой цепочке хранятся значения, которые имеют ссылку на next элемент и на prev элемент.
	

# TREEMAP
Основан на красно-черном дереве, при чем сбалансированных. Отсортирован ко ключу. Что бы сортировать в TreeMap собственный класс, необоходимо в классе реализовать интерфейс Comparable. Появится метод compareTo, который будет использоваться для сравнения ключей. Не синхронизирован.
Объекты сохраняются в отсортированном порядке по возрастанию. Время доступа и извлечения элементов достаточно мало, что делает класс TreeMap блестящим выбором для хранения больших объемов отсортированной информации, которая должна быть быстро найдена.
TreeMap основан на Красно-Черном дереве, вследствие чего TreeMap сортирует элементы по ключу в естественном порядке или на основе заданного вами компаратора.
Содержит упорядоченные данные отсортированные по компоратору. Почти во всех операциях участвует компаратор, а поиск например вернет запись если при сравнении компаратор выведет compareTo(p.key); == 0, 
При добавлении сравнивает с рутовым элементов (рут - первая запись в мапе), и дальше в зависимости больше или равно сравнивается с left или right записями:
			do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);

# Отличия HashMap от Hashtable:
	- Hashtable синхронизирован в отличии от Hashmap (соответственно производительность Hashtable хуже);
	- HashMap позволяет использовать null в качестве ключей и значений;
	- Наличие синхронизации в Hashtable уменьшает производительность кода, использующего данный класс. Поэтому классы JCF (Java Collections Framework, появившийся в Java 2), в том числе и HashMap, несинхронизированы. Если синхронизация все же нужна, можно использовать методы класса Collections: Collections.synchronizedMap(map), Collections.synchronizedList(list) или Collections.synchronizedSet(set). Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае итерирования по коллекции требуется ручная синхронизация. Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как CopyOnWriteArrayList и ConcurrentHashMap.

IdentityHashMap - это структура данных, реализующая интерфейс Map, но использующая сравнение ссылок вместо метода equals() при сравнении ключей (значений). Другими словами, в IdentityHashMap два ключа k1 и k2 будут рассматриваться равными, если выполняется условие k1 == k2 (в стандартной реализации интерфейса Map (например, HashMap) ключи k1 и k2 считаются равными, если выполняется условие (k1 == null ? k2 == null : k1.equals(k2))). IdentityHashMap не использует метод hashCode(), вместо которого применяется метод System.identityHashCode(Object).

WeakHashMap - это структура данных, реализующая интерфейс Map и основанная на использовании WeakReference для хранения ключей. Таким образом, пара "ключ-значение" будет удалена из WeakHashMap, если на объект-ключ более не имеется сильных ссылок.

TreeSet - объекты хранятся отсортированными по возрастанию в порядке сравнения. LinkedHashSet - хранение элементов в порядке добавления (при чем скорость поиска как у HashSet).


===================================
===================================

# java.util.concurrent.*
ArrayBlockingQueue, ConcurrentHashMap, AtomicInteger, Collections.synchronizedList(new LinkedList()) и другие интересности.
Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета.
Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков.
Synchronizers — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.
Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.
Создаем ExecutorService exec = Executors.newCachedThreadPool(); Затем передаем методу execute экземпляр нашего класса. В конце вызываем shutdown(), который предотвращает передачу Executor новых задач.
Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.
Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.

Callable используется вместо Runnable для того, что бы задача возвращала значение. Перегруженный метод Executors.callable() получает Runnable и выдает Callable.
Потоки-демоны завершают свои методы run() без выполнения секций finally.

# Arrays, Collections
Семейства Arrays и Collections в java.util содержат вспомогательные методы для включения групп лементов в коллекции. Метод Arrays.asList() получает либо массив, либо список элементов, разделенных запятыми, и, преобразует его в объект List. Метод Collections.addAll() получает объект Collection и либо массив, либо список, разделенный запятыми, и добавляет элементы в Collection.

===================================
===================================

# ИТЕРАТОРЫ
Итератор - это объект, обеспечивающий перемещение по последовательности объектов с выбором каждого объекта этой последовательности, при это программисту-клиенту не надо знать или заботиться о лежащей в ее основе структуре. Вдобавок, итератор обычно является так называемым "легковесным" объектом: его создание должно обходиться без заметных затрат ресурсов. Из-за этого итераторы часто имеют ограничения; Iterator в Java поддерживает перемещение только в одном направлении. С его возможностью можно сделать следующее:
- Запросить у контейнера итератор вызовом метода iterator(). Полученный итератор готов вернуть начальный элемент последовательности при первом вызове своего метода next().
- Получить следующий элемент последовательности вызовом метода next().
- Проверить, остались ли еще объекты в последовательности (метод hasNext()).
- Удалить из последовательности последний элемент, возвращенный итератором, метдом remove().

ListIterator - более мощная разновидность Iterator, поддерживаемая только классами List. Он является двусторонним. Так же он может выдавать индексы следующего и предыдущего элементов по отношению к текущей позиции. Заменять последний посещенный элемент методом set(). Вызов listIterator() возвращает итератор в начало листа, а с listIterator(n) возвращает итератор в позицию n.


