# WEB APPLICATION
	Web Archive или Web Application Archive — формат файла, описывающий, как полное веб-приложение упаковывается в соответствии со спецификацией Java-сервлетов в файл в формате JAR или ZIP. Такие файлы имеют расширение «.war» и поэтому называются ещё «WAR-файлами».
Преимущества WAR-файлов:
	- лёгкость разработки, тестирования и развертывания
	- версию развёрнутого приложения легко идентифицировать
	- Все J2EE-контейнеры поддерживают WAR-файлы
/index.html
/guestbook.jsp
/images/logo.png
/WEB-INF/web.xml
/WEB-INF/classes/org/wikipedia/Util.class
/WEB-INF/classes/org/wikipedia/MainServlet.class
/WEB-INF/lib/util.jar
/META-INF/MANIFEST.MF
	В каталоге «WEB-INF» находится так называемый дескриптор развёртывания («Deployment Descriptor»: в свободном переводе — «инструкция по применению») по имени «web.xml», определяющий все сервлеты и другие свойства Web-приложения. Если приложение содержит только JSP-файлы, этот файл не строго обязателен.
	Директория /WEB-INF/classes находится в classpath ClassLoader. Эти java-файлы с расширением .class будут загружены, когда веб-приложение загрузится и начнет выполняться. Любые файлы JAR, находящиеся в каталоге /WEB-INF/lib, также будут помещены в classpath.
	Чтобы веб-контейнер (веб-сервер) смог прочитать дескриптор развертывания и начал перенаправлять запросы на данное приложение, необходимо развернуть (deploy) WAR-файл в контейнер. Одним из вариантов выполнения развёртывания является копирование WAR-файла в autodeploy-каталог веб-контейнера.
	WAR может быть подписан электронной цифровой подписью так же, как и JAR-файл, чтобы подтвердить аутентичность кода.



# WEB.XML
	Дескриптор развертывания — это конфигурационный файл артефакта, который будет развернут в контейнере сервлетов. В спецификации Java EE дескриптор развертывания описывает то, как компонент, модуль или приложение (такое, как веб-приложение или приложение предприятия) должно быть развернуто.
	Этот конфигурационный файл указывает параметры развертывания для модуля или приложения с определенными настройками, параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора развертывания используется язык XML.
	Для веб-приложений дескриптор развертывания должен называться web.xml и находиться в директории WEB-INF, в корне веб-приложения. Этот файл является стандартным дескриптором развертывания, определенным в спецификации Сервлетов. 
<web-app>
     <servlet>
         <servlet-name>HelloServlet</servlet-name>
         <servlet-class>mypackage.HelloServlet</servlet-class>
     </servlet>
 
     <servlet-mapping>
         <servlet-name>HelloServlet</servlet-name>
         <url-pattern>/HelloServlet</url-pattern>
     </servlet-mapping>
 
     <resource-ref>
         <description>
             Resource reference to a factory for javax.mail.Session
             instances that may be used for sending electronic mail messages,
             preconfigured to connect to the appropriate SMTP server.
         </description>
         <res-ref-name>mail/Session</res-ref-name>
         <res-type>javax.mail.Session</res-type>
         <res-auth>Container</res-auth>
     </resource-ref>
 </web-app>




# SERVER TYPES
    Сервер приложений  - компонентный сервер, исполняющий приложения для работы с клиентом. Он предоставляет разработчику стандартный фреймворк, контейнер сервлетов итд.
    Веб-сервер – узкоспециализированный сервер, взаимодействующий  с клиентом по протоколу http. Отличается от сервера приложений узкой специализацией.
    Пример веб-сервера  - tomcat, сервера приложений – JBOSS и Glassfish.



# HTTP
	При использовании метода POST данные передаются в зашифрованном виде. В GET есть ограничение на размер передаваемой в запросе строки.
    По умолчанию выполняется GET.

    HTTP - протокол прикладного уровня передачи данных. Основой http является технология "клиент-сервер". Особенностью протокола http является возможность указать в азпросе и ответе способ представления одного и того же ресурса по различным парамтерам: формату, кодировке, языку и т.д. (В частности для этого используется http-заголовок). Для идентификации ресурсов http использует глобальне URI. В отличие от других протоколов, http не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами "запрос-ответ". 

    Все ПО для работы с http делится на:
    - Серверы (обработка запросов)
    - Клиенты (отправка запроса)
    - Прокси для выполнения транспортных служб

    Каждое http-сообщение состоит из следующих частей (передаются в указанном порядке):
    - Стартовая строка (Starting line) - определяет тип сообщения;
    - Заголовки - характеризуют тело сообщения, параметры передачи и прочие сведения;
    - Тело соощения (обязательно должно отделяться от заголовков пустой строкой).



# COOKIES
	Небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя, на практике обычно используется для:
	- аутентификации пользователя;
	- хранения персональных предпочтений и настроек пользователя;
	- отслеживания состояния сеанса доступа пользователя;
	- ведения статистики о пользователях.

	Установка куки:
	- Запрашивая страницу, браузер отправляет веб-серверу короткий текст с HTTP-запросом.
	- Сервер отвечает, отправляя запрашиваемую страницу вместе с текстом, содержащим HTTP-ответ. Там может содержаться указание браузеру сохранить куки (Set-Cookie: name=value)
	- Строка Set-cookie отправляется лишь тогда, когда сервер желает, чтобы браузер сохранил куки. В этом случае, если куки поддерживаются браузером и их приём включён, браузер запоминает строку name=value (имя = значение) и отправляет её обратно серверу с каждым последующим запросом. (Cookie: name=value)
	- Этот запрос отличается от первого запроса тем, что содержит строку, которую сервер отправил браузеру ранее. Таким образом, сервер узна́ет, что этот запрос связан с предыдущим. Сервер отвечает, отправляя запрашиваемую страницу и, возможно, добавив новые куки.

	Куки также могут устанавливаться программами на языках типа JavaScript, встроенными в текст страниц, или аналогичными скриптами, работающими в браузере. В JavaScript для этого используется объект document.cookie. Например, document.cookie = "temperature=20" создаст куки под именем «temperature» и значением 20.



# HTTP SESSION
	Это соединение клиента с сервером, устанавливаемой на определённое время, за которое клиент может сделать любое количество запросов к серверу (на стороне сервера).
	Большинство протоколов предусматривают установление TCP-сессии, в ходе которой один раз происходит авторизация, и дальнейшие действия выполняются в контексте этой авторизации. HTTP же устанавливает отдельную TCP-сессию на каждый запрос; в более поздних версиях HTTP было разрешено делать несколько запросов в ходе одной TCP-сессии, но браузеры обычно запрашивают только страницу и включённые в неё объекты (картинки, каскадные стили и т. п.), а затем сразу разрывают TCP-сессию. Для поддержки авторизованного (неанонимного) доступа в HTTP используются cookies; причём такой способ авторизации позволяет сохранить сессию даже после перезагрузки клиента и сервера.



# SERVLET
    Контейнер сервлетов -  программа, управляющая жизненным циклом сервлетов.
    Сервлет – класс, отвечающий за обработку запросов клиента и отправку ответов. Основные методы сервлета: init() – запускается сразу после  загрузки сервлета в память; service() – вызывается для обработки каждого запроса; destroy() – выполняется перед выгрузкой сервлета из памяти.
    Жизненный цикл сервлета: им управляет контейнер сервлетов, при первом обращении к сервлету происходит его загрузка в память и вызывается  метод init(). На протяжении работы приложения происходят вызовы методы service() для обработки запросов клиента. По завершению работы приложения вызывается метод destroy() и сервлет выгружается из памяти.

    При проектировании сервлетов нужно уделить особое внимание тому, чтобы сервлет был thread-safe. Не использовать переменные экземпляра, например. Либо синхронизировать к ним доступ. В общем, рассчитывайте на то, что методы сервлета будут вызываться из разных потоков.

    Для обращения к сервлету из браузерной строки надо написать маппинг сервлета. Метод сервлета нельзя напрямую вызвать из браузерной строки. Для вызова из браузерной строки конкретного сервлета в строке браузера пишется ip-aдрес хоста, номер порта, имя приложения и маппинг сервлета.
    С помощью HttpServletRequestWrapper и HttpServletResponseWrapper можно изменять запрос и ответ соответственно.
    Фильтры выполняются в той последовательности, в которой они заданы в FilterChain.



# Сервлетные фильтры
	Сервлетный фильтр, в соответствии со спецификацией, это Java-код, пригодный для повторного использования и позволяющий преобразовать содержание HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTML. Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.
	Сервлетные фильтры могут:
	- перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;
	- определить содержание запроса прежде, чем сервлет будет инициирован;
	- модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;
	- модифицировать заголовки и данные ответа, в которые упаковывается получаемый ответ;
	- перехватывать инициацию сервлета после обращения к сервлету.
	Сервлетный фильтр может быть конфигурирован так, что он будет работать с одним сервлетом или группой сервлетов. Основой для формирования фильтров служит интерфейс javax.servlet.Filter, который реализует три метода:
		void init (FilterConfig config) throws ServletException;
		void destroy ();
		void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;
	Фильтры могут использоваться для кэширования и сжатия контента, логирования и аудита, преобразования изображений, аутентификации входящих реквестов, XSL трансформации XML контента, локализации реквеста и респонса и т.д. Фильтра - это модифицированная версия паттерна "Цепочка обязанностей". Если необходимо модифицировать реквест или респонс в цепочке можно испозовать Декоратор.



# JSP
	JSP – веб-страница, представляющая собой комбинацию статического html и java-кода. 
    Жизненный цикл JSP. Исходный код jsp, к которой идёт запрос от клиента, анализируется и парсится jsp_engine, далее создаётся временный сервлет, основанный на коде jsp. Далее сервлет компилируется. Запускаются методы init() и jsp_service(). После обработки методом jsp_service() отсылается ответ клиенту в виде html.

    Выполнению контракта между JSP-контейнером и автором JSP-страницы помогает требование о том, что класс Servlet, соответствующий JSP-странице, обязан реализовывать интерфейс HttpJspPage (или интерфейс JspPage, если протокол - не HTTP).
    Контракт между JSP-контейнером и Java-классом, реализующим JSP-страницу, соответствует интерфейсу Servlet.

    Если автор JSP-страниц использует extends, за исключением того, что имя этого класса это имя, специфицированное в атрибуте extends.
	Контракт класса реализации JSP-страницы не изменяется. JSP-контейнер должен проверить (обычно через отражение/reflection), что предоставленный суперкласс:
	- Реализует HttpJspPage, если протокол - HTTP, либо JspPage - в ином случае.
	- Все методы в интерфейсе Servlet объявлены final.
	- Дополнительно к этому, автор JSP-страницы отвечает за то, штаа предоставленный суперкласс выполняет следующее:
		метод service() из Servlet API вызывает метод _jspService();
		метод init(ServletConfig) хранит конфигурацию, даёт к ней доступ как к getServletConfig, затем вызывает jspInit;
		метод destroy вызывает jspDestroy.
	- JSP-контейнер может выдавать фатальную ошибку трансляции, если обнаружит, что предоставленный суперкласс не удовлетворяет этим требованиям, но большинство JSP-контейнеров эту проверку не будут выполнять.

	Неявные объекты (implicit objects) - это объекты, автоматически доступные как часть стандарта JSP без их специального объявления или импорта. Эти объекты, список которых представлен в таблице, можно использовать в коде JSP (request, response, out, pageContext, session, application, confit, page, exception)

	Your JSP generated servlet can extend your own servlet with the directive:
		<%@ page extends=”com.CRMServlet”%> 

	How will you perform a browser redirection from a JSP page?
		<% response.sendRedirect(“http://www.someAbsoluteAddess.com”); %>
	or you can alter the location HTTP header attribute as follows:
		<%
 			response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
 			response.setHeader(“Location”, “/someNewPath/index.html”);
		%>
	How do you prevent the HTML output of your JSP page being cached?
		<%
		 response.setHeader(“Cache-Control”, “no=store”); //HTTP 1.1
		 response.setDateHeader(“Expires”, 0);
		%>
	You can invoke a Servlet from a JSP through the jsp:include and jsp:forward action tags.
		<jsp:include page=”/servlet/MyServlet” flush=”true” />
	 How do you forward a request to another resource (e.g. another Servlet) from within your JSP? 
	 	<jsp:forward page=”/anotherPage.jsp” /> 
	 You can prevent the creation of useless sessions with the attribute “session” of the page directive.
		<%@ page session=”false” %>

	Static include <%@ include %> определяет один сервлет на стадии компиляции. Dynamic include <jsp:include …..> компилируется в отдельные сервлеты.




# jsp:useBean scopes
	Тег jsp:useBean позволяет ассоциировать экземпляр Java-класса, определенный в данной области видимости scope, с заданным внутренним идентификатором этого класса id в данной странице JSP. Прежде, чем использовать свойства компонента JavaBean (setProperty и getProperty), необходимо объявить тег jsp:useBean. При выполнении тега jsp:useBean сервер приложений обеспечивает поиск (lookup) экземпляра данного Java-класса, пользуясь значениями, определенными в атрибутах:
		id - идентификатор экземпляра класса внутри страницы JSP;
		scope - область видимости (page, request, session, application).
	Если объект с данными атрибутами id, scope не найден, предпринимается попытка создать объект, используя значения, определенные в его атрибутах.
	При наличии в объявление тела, оно будет вызвано на выполнение, если компонент JavaBean, к которому обращено действие, уже существует. Содержимое тела действия строго не ограничено, однако, как правило, тело действия содержит скриптлеты или теги jsp:setProperty, модифицирующие свойства созданного объекта.
	Scopes:
	- page (страница). Объект, определенный с областью видимости page, доступен до тех пор, пока не будет отправлен ответ клиенту или пока запрос к текущей странице JSP не будет перенаправлен куда-нибудь еще. Ссылки на объект возможны только в пределах страницы, в которой этот объект определен. Объекты, объявленные с атрибутом page, сохраняются в объекте pageContext.
	- request (запрос). Объект, имеющий область видимости request, существует и доступен в течение текущего запроса, и остается видимым, даже если запрос перенаправляется другому ресурсу в том же самом цикле выполнения. Объекты, декларированные с атрибутом области видимости request, сохраняются в объекте request.
	- session (сессия). Объект, имеющий область видимости session доступен в течение текущего сеанса, если страница JSP "знает" о сеансе.
	- application (приложение). Объект, имеющий область видимости application доступен страницам, обрабатывающим запросы в одном и том же приложении Web, и cуществует до тех пор, пока сервер приложений поддерживает объект ServletContext. Объекты, объявленные с атрибутом области видимости application, сохраняются в объекте application.



# ServletRequest.dispatch vs ServletContext.dispatch
	ServletRequest имеет методы для работы с аттрибутами, доступ к параметрам, с которыми был запущен сервер.




# FORWARD/REDIRECT
    - Forward осуществляется переход на новую страницу, но запрос не меняется (на сервере). Передает на сервере запрос на другой url.
    - Redirect создаётся новый запрос, все параметры, хранившиеся в старом удаляются.  Также редирект ‘убивает‘ переменные сессии (через клиента). Меняет адрес странички. То есть при редиректе 1 запроса сервер возвращает ответ клиенту у которого меняется урл в браузере и браузер опять отсылает запрос.



# CUSTOM TAG
	Некоторыми примерами задач, которые могут быть выполнены при помощи пользовательских тегов, являются операции над скрытыми объектами, обработка форм, обращение к базам данных и к другим корпоративным службам, таким как электронная почта и службы каталогов, выполнение передачи управления. Библиотеки JSP-тегов создаются разработчиками, являющимися профессионалами в языке программирования Java и экспертами в области доступа к данным и другим службам. Эти библиотеки используются дизайнерами Web-приложений, которые могут сосредоточиться на вопросах презентации, а не заниматься доступом к корпоративным службам. В дополнение к обнадеживающему разделению труда между разработчиками библиотеки и пользователями библиотеки пользовательские теги увеличивают производительность посредством инкапсуляции повторяющихся задач, что дает возможность их повторного использования в более чем одном приложении.

	Пользовательские теги имеют богатый набор возможностей. Они могут:
	- Быть настроенными при помощи атрибутов, переданных из вызывающей страницы.
	- Обращаться ко всем объектам, доступным JSP-странице.
	- Изменять ответ, генерируемый вызывающей страницей.
	- Взаимодействовать между собой. Вы можете создать и инициализировать компонент JavaBeans, создать переменную, обращающуюся к этому компоненту в одном теге, и затем использовать этот компонент в другом теге.
	- Быть вложенными, разрешая сложные взаимодействия в JSP-странице.

	<%@ taglib uri="/WEB-INF/tutorial-template.tld" prefix="tt" %>

	Для определения тега необходимо:
	- Разработать обработчик тега и вспомогательный класс для тега
	- Объявить тег в дескрипторе библиотеки тегов

	JSTL позволяет не использовать java код на jsp страницах. В JSTL используется expression language для упрощения доступа к данным, хранящимся в различных областях видимости (page, request, session, application ).
	Основные jstl-теги: out,set,remove,if,choose,redirect, import, forEach итд.

	JSTL состоит и 4 основных библиотек тегов:
		- Core Tag Library (циклы, if, input)
		- Formattin/I18n (парсинг даты)
		- XML Tag Library (для доступа к XML элементам)
		- Database Tag Library (для запросов к бд) <sql:query var=”emps” sql=”SELECT * FROM Employee”>

	Есть методы doStartTag(), doEndTag(), doInitBody(), doAfterBody(), которые запускаются при срабатывании соответствующего события. В них заключается обработка данных, переданных в тег, и вывод результата. Неободимо расширить класс TagSupport и переопределить его методы.


Prohibit caching of application pages by inserting the following lines in your pages:
 <meta HTTP-EQUIV=”pragma” content=”no-cache” />
 <meta HTTP-EQUIV=”Expires” content=”-1” /> 


 Для улучшения перфоманса J2EE приложения необходимо следовать следующим правилам:
 	- создать пул ресурсов (для подключений или потоков)
 	- использовать паттерны
 	- поставить таймауты для сессионных объектов
 	- использовать PreparedStatements 
 	- освобождать коннекшн к ДБ в блоке finally

 J2EE best practices:
 	- автоматизировать процесс сборки с Ant или Maven
 	- использовать JUnit
 	- использовать только необходимые паттерны
 	- правильно использовать исключения
 	- избегать утечек памяти закрывая все конекшены к БД после использования



