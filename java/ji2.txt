===================================
=  EXCEPTIONS                     =
===================================

# EXCEPTIONS
— Throwable и Exception и все их наследники (за исключением наследников Error-а и RuntimeException-а) — checked
— Error и RuntimeException и все их наследники — unchecked

                    Object
                      |
                  Throwable
                  /      \
              Error     Exception
                            |
                    RuntimeException

Необходимо понимать, что 
— проверка на cheched исключения происходит в момент компиляции (compile-time checking)
— перехват исключений (catch) происходит в момент выполнения (runtime checking)

Все классы обрабатывающие ошибки являются наследниками класса java.lang.Throwable. Только объекты этого класса или его наследников могут быть "брошены" JVM при возникновении какой-нибудь исключительной ситуации, а также только эти объекты могут быть "брошены" во время выполнения программы с помощью ключевого слова throw.
Прямыми наследниками класса Throwable являются Error и Exception.

Error - это подкласс, который показывает серьезные проблемы возникающие во время выполнения приложения. Большинство из этих ошибок сигнализируют о ненормальном ходе выполнения программы, т.е. о каких-то критических проблемах. Эти ошибки не рекомендуется отмечать в методах посредством throws-объявления, поэтому они также очень часто называются непроверяемые (unchecked). Примерами таких исключений являются: ThreadDeath, VirtualMachineError, OutOfMemoryError.

Exception - это подкласс исключений, которые приложение может "выбрасывать" во время своей работы и которые должны быть обработаны в тех методах, где они возникают, или "проброшены" дальше, для обработки на более позднем этапе. Это обычно проверяемые (checked) исключения. Примерами являются: ClassNotFoundException, IOException.

У класса Exception есть один подкласс, который не рекомендуется декларировать в методах с помощью throws. Это RuntimeException и все его наследники. Исключения этого типа возникают во время выполнения программы. Поскольку они могут возникнуть в любом методе, то пришлось бы декларировать их везде, что существенно усложнило бы жизнь разработчикам. Вместо этого рекомендуется в коде программы делать необходимые проверки, чтоб избежать возникновения этих исключений. IndexOutOfBoundsException, IllegalArgumentException, NullPointerException.

Cвойством транзакционности исключения не обладают – действия, произведенные в блоке try до возникновения исключения, не отменяются поcле его возникновения.

При написании бизнес-логики – в особенности это касается библиотек – часто бывает полезным создать собственный тип исключения. Просто для того, чтобы дать возможность обрабатывать ваши исключения отдельно от остальных. Иехрархия исключений JDK не может предусмотреть все возможные ошибки, поэтому вы вправе создавать собственные типы исключений для обозначения специфических ошибок вашей программы.

- создается объект, представляющий исключение;
- текущий поток останавливается, и ссылка на объект, представляющий исключение, извлечкается из текущего контекста;
- включается механизм обработки исключений, который начинает поиск подходящего места программы для передачи исключения;
- таким местом является обработчик исключений, который пытается решить возникшую проблему так, чтобы программа могла снова попытаться выполнить проблемную операцию или просто продолжила свое выполнение.

"Обмануть" компилятор все можно: вы вправе объявить о возбуждении исключения, которого на самом деле нет. Компилятор верти вам на слово и заставляет пользователей метода поступать так, как будто им и в самом деле необходимо перехватывать исключение. Таким образом можно "зарезервировать" исключение на будущее и уже потом возбуждать его, не изменяя описания готовой программы. 

Выполнение finally можно избежать например при системном выходе из программы в блоке try: System.exit(0);


===================================
=  COLLECTIONS                    =
===================================

= ARRAYLIST =
Только что созданный объект list, содержит свойства elementData и size. Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов типа Object (с приведением к типу, разумеется).

Добавление в конец списка. Внутри метода add(value) происходят следующие вещи:
1) проверяется, достаточно ли места в массиве для вставки нового элемента;
	ensureCapacity(size + 1);
2) добавляется элемент в конец (согласно значению size) массива.
	elementData[size++] = element;

Добавление в «середину» списка (list.add(5, "100");)
1) проверяется, достаточно ли места в массиве для вставки нового элемента;
	ensureCapacity(size + 1);
2) подготавливается место для нового элемента с помощью System.arraycopy();
	System.arraycopy(elementData, index, elementData, index + 1, size - index);
3) перезаписывается значение у элемента с указанным индексом.
	elementData[index] = element;
	size++;

Удалять элементы можно двумя способами:
— по индексу remove(index)
— по значению remove(value)

С удалением элемента по индексу всё достаточно просто
	list.remove(5);
Сначала определяется какое количество элементов надо скопировать
	int numMoved = size - index - 1;
затем копируем элементы используя System.arraycopy()
	System.arraycopy(elementData, index + 1, elementData, index, numMoved);
уменьшаем размер массива и забываем про последний элемент
	elementData[--size] = null; // Let gc do its work


= LINKEDLIST =
Только что созданный объект list, содержит свойства header и size.
header — псевдо-элемент списка. Его значение всегда равно null, a свойства next и prev всегда указывают на первый и последний элемент списка соответственно. Так как на данный момент список еще пуст, свойства next и prev указывают сами на себя (т.е. на элемент header). Размер списка size равен 0.
	header.next = header.prev = header;

Добавление элемента в конец списка с помощью методом add(value), addLast(value) и добавление в начало списка с помощью addFirst(value) выполняется за время O(1).
Каждый раз при добавлении нового элемента, по сути выполняется два шага:
1) создается новый новый экземпляр класса Entry
	Entry newEntry = new Entry("0", header, header.prev);
2) переопределяются указатели на предыдущий и следующий элемент
	newEntry.prev.next = newEntry;
	newEntry.next.prev = newEntry;
	size++;

- Базовый контейнер ArrayList, оптимизированный для произвольного доступа к элементам, но с относительно медленными операциями вставки (удаление) элементов в середине списка.
- Контейнер LinkedList, оптимизированный для послдеовательного доступа, с быстрыми операциями вставки (удаления) в середине списка. Произвольный доступ к элементам LinkedList выполняется относительно медленно, но по широте возможностей он превосходит ArrayList. 
Используйте ArrayList при частом использовании произвольного доступа к элементам или LinkedList при частом выполнении операций вставки и удаления в середине списка.

===================================
===================================

FORWARD/REDIRECT
    Forward осуществляется переход на новую страницу, но запрос не меняется (на сервере). Передает на сервере запрос на другой url.
    Redirect создаётся новый запрос, все параметры, хранившиеся в старом удаляются.  Также редирект ‘убивает‘ переменные сессии (через клиента). Меняет адрес странички. То есть при редиректе 1 запроса сервер возвращает ответ клиенту у которого меняется урл в браузере и браузер опять отсылает запрос.

===================================
===================================

TRANSIENT
Оно применяется к полям класса и означает, что данное поле не входит в персистентное состояние класса.
Т.е. при сериализации данное поле не будет записываться. И, соответственно, при де-сериализации оно не будет восстанавливаться из потока байтов. 

===================================
===================================

Атомарность означает выполнение операции целиком непрерывно (либо невыполнение ее вовсе).
	В Java атомарными являются операции чтения/записи всех примитивных типов данных за исключением типов long и double, поскольку эти типы данных занимают два машинных слова, их операции чтения/записи являются составными операциями из двух атомарных операций над старшими и младшими битами числа соответственно.
	Однако операции над volatile long и volatile double атомарны.
	Операции над ссылками на объекты в Java являются всегда атомарными независимо от разрядности JVM и гарантируются JMM.
 
===================================
===================================

Inversion of Control (инверсия управления) — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода.
Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других 
компонентов.
Dependency Injection (внедрение зависимостей) — это одна из реализаций этого принципа (помимо этого есть еще Factory Method, Service Locator).
 
===================================
===================================

Spring. BeanFactory - это базовый интерфейс. Самые начальные его реализации передают например путь к xml (или даже properties) конфигурации и дальше можно доставтаь бины.
Продвинутая реализация ApplicationContext - она с поддержкой транзакций, AOP, обрабботка событий и тд. 
http://j4sq.blogspot.com/2012/01/java-spring-hibernate.html
 
===================================
===================================

REST - это архитектурный стиль, стандарт для создания веб сервисов. REST - метод взаимодействия компонентов распределённого приложения в сети Интернет, при котором вызов удаленной процедуры представляет собой обычный HTTP-запрос (обычно GET или POST; такой запрос называют REST-запрос), а необходимые данные передаются в качестве параметров запроса.
RESTFull - набор АПИ, которые следуют стилю REST
 
===================================
===================================

Maven - mvn archetype:create -DgroupId=com.mycompany.app -DartifactId=my-webapp  -DarchetypeArtifactId=maven-archetype-webapp - создает структуру проекта по архетипу.
            mvn install:install-file -Dfile=<path-to-file> -DgroupId=<group-id> -DartifactId=<artifact-id> -Dversion=<version> -Dpackaging=<packaging>  - инсталим артифакт в репозиторий.
	Nexus - через него можно настроить собственный репозиторий.
	maven-jar-plugin - плагин собирает в jar.
	maven-dependency-plugin - копирует зависимости в указанную директорию.
	jetty-maven-plugin - подключает к проекту джетти - то есть запускает сервер из джавы.
	maven-ejb-plugin - собирает ejb проект.
	maven-ear-plugin - собирает ear проект.
	maven-compiler-plugin - компилирует проект.
 
===================================
===================================

SQL, запросы, join  и тд.
	inner join - INNER JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах.
	left outer join - JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах + строки которые присутствуют только в левой колонке.
	right outer join -  JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах + строки которые присутствуют только в правой колонке.
	
	INSERT INTO table1 (username) VALUES ('foo'); 
	UPDATE table2 SET user_id='2', phone_number='200' WHERE phone_id='1';
	DELETE FROM table1 WHERE user_id = 1; 
	RENAME TABLE table1 TO nya;
	ALTER TABLE lcssm.application ADD CONSTRAINT uk_application_application_number UNIQUE (application_number);
	ALTER TABLE lcssm.application DROP CONSTRAINT uk_application_application_number;
	ALTER TABLE lcssm.application ADD CONSTRAINT chk_application_additional_info CHECK (additional_info <> '');
	ALTER TABLE lcssm.documents ALTER date DROP NOT NULL;
	ALTER TABLE lcssm.documents ALTER date SET NOT NULL;
	alter table lcssm.houses add column change_date bigint NOT NULL;
	alter table lcssm.houses drop column change_date;
	update lcssm.licenses set original_license_guid = null where version_number = 1;	
	group by групирует по строке, а having используется только вместе с group by и слежит для фильтрации по колонкам в group by.
 
===================================
===================================

Приниципы ACID:
Atomicity — Атомарность - Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние — со стороны будет казаться, что транзакции и не было. (Естественно, счётчики, индексы и другие внутренние структуры могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.)
	
Consistency — Согласованность - Транзакция достигающая своего нормального завершения (EOT – end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвертого свойства.Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисление, то система останется в некорректном состоянии и свойство согласованности будет нарушено.Наконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего,двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции, никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.
	 
Isolation — Изолированность - Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат. Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности Repeatable Read и ниже).

	Durability — Надежность - Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой 
транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может 
быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.
 
===================================
===================================

ArrayList - когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных мест, то вызов System.arraycopy() случится дважды: первый в ensureCapacity(), второй в самом методе add(index, value),
 что явно скажется на скорости всей операции добавления.
	В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину»,
	стоит использовать метод addAll(index, Collection). И хотя, данный метод скорее всего вызовет System.arraycopy() три раза,
	в итоге это будет гораздо быстрее поэлементного добавления.
	— Быстрый доступ к элементам по индексу за время O(1);
	 — Доступ к элементам по значению за линейное время O(n);
	 — Медленный, когда вставляются и удаляются элементы из «середины» списка;
	 — Позволяет хранить любые значения в том числе и null;
	 — Не синхронизирован.
	http://habrahabr.ru/post/128269/
	
LinkedList - связанный список, хранит элементы каждый из каторых имеет ссылку на предыдущий и следующий элемент.
 Поддерживает двунапрвленный итератор.
	— Из LinkedList можно организовать стэк, очередь, или двойную очередь, со временем доступа O(1);
	 — На вставку и удаление из середины списка, получение элемента по индексу или значению потребуется линейное время O(n).
	 Однако, на добавление и удаление из середины списка, используя ListIterator.add() и ListIterator.remove(), потребуется O(1);
	 — Позволяет добавлять любые значения в том числе и null. Для хранения примитивных типов использует соответствующие классы-оберки;
	 — Не синхронизирован.
	 
HashMap - — Добавление элемента выполняется за время O(1), потому как новые элементы вставляются в начало цепочки;
		 — Операции получения и удаления элемента могут выполняться за время O(1), если хэш-функция равномерно распределяет элементы 
		 и отсутствуют коллизии. Среднее же время работы будет ?(1 + ?), где ? — коэффициент загрузки. В самом худшем случае, 
		 время выполнения может составить ?(n) (все элементы в одной цепочке);
		 — Ключи и значения могут быть любых типов, в том числе и null. Для хранения примитивных типов используются соответствующие классы-оберки;
		 — Не синхронизирован.
		 В каждой цепочке хранятся значения, которые имеют ссылку на next элемент.

LinkedHashMap - Данная структура может слегка уступать по производительности родительскому HashMap, при этом время выполнения операций add(),
 contains(), remove() остается константой — O(1). Понадобится чуть больше места в памяти для хранения элементов и их связей, 
 но это совсем небольшая плата за дополнительные фишечки.
	 Вообще, из-за того что всю основную работу на себя берет родительский класс, серьезных отличий в реализации HashMap и 
	 LinkedHashMap не много. Можно упомянуть о парочке мелких:
	Методы transfer() и containsValue() устроены чуть проще из-за наличия двунаправленной связи между элементами;
	В классе LinkedHashMap.Entry реализованы методы recordRemoval() и recordAccess() 
	(тот самый, который помещает элемент в конец при accessOrder = true). В HashMap оба этих метода пустые.
	В каждой цепочке хранятся значения, кторые имеют ссылку на next элемент и на prev элемент.
	
	
TreeMap  - содержит упорядоченные данные отсортированные по компоратору. Почти во всех операциях участвует компаратор,
 а поиск например вернет запись если при сравнении компаратор выведет compareTo(p.key); == 0, 
При добавлении сравнивает с рутовым элементов (рут - первая запись в мапе),
и дальше в зависимости больше или равно сравнивается с left или right записями:
do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
	
HashSet - внутри использует HashMap. Плюсы в постоянном доступе таких методов как add contain remove size.
TreeSet - внутри использует TreeMap.
 
List, Set, Queue, Deque, Map(не наследуется от Collection). 
Set от List отличается тем, что в Set могут содержаться только уникальные объекты.  
Queue и Deque характеризуются тем, что элементы извлекаются в том же порядке, в котором ложатся (FIFO).
ArrayList обеспечивает наилучшее быстродействие, когда требуется часто извлекать произвольные объекты.
LinkedList - когда требуется много добавлять и удалять произвольные объекты.
HashTable, в отличие от HashMap, потокобезопасный, но более медленный. Однако, применять HashTable не стоит никогда, так как для многопоточности существует более новый и совершенный  ConcurrentHashTable.  Кроме неё, в пакете concurrent есть полезная коллекция ArrayBlockingQueue, которая представляет собой  упорядоченную блокирующую очередь, ей удобно применять для пулов соединений с БД


===================================
===================================

EJB - @StartUp - бин создается сразу после деплоя приложения. @Singleton -  бин будет существовать только в 1 экземпляре.
	Enterprise beans поддерживают два типа управления транцакциями: container-managed или bean-managed. По умолчанию, если явно не задано,
	то используется первый, с которым я сегодня разбирался и хочу рассказать.
	 По сути, это просто заметки, сделанные с документации Java EE 6 Tutorial.
	 Container-managed транзакции упрощают разработку, т.к. за границами транзакции следит контейнер EJB.
	 Транзакции, управляемые контейнером, могут работать как с session, так и с message-driven бинами.
	 Транзакция автоматически стартует перед началом запуска метода в бине и заканчивается по завершении этого метода.
	 Container-managed транзакции не поддерживают вложенные и мульти-транзакции.
	 Container-managed транзакция не должна использовать методы управления транзакциями, т. к. эти операции возложены на контейнер EJB.
	 Существует возможность управления запуском транзакций для ejb-методов. Если внутри транцакции вызывается метод другого бина,
	 то как должна вести себя транзакция с этим методом? На этот метод можно поставить различные ограничители принадлежности к текущей транзакции,
	 при помощи аннотации @TransactionAttribute:
	 Ограничения транзакции:
	REQUIRED - если метод запущен внутри транзакции, то он является частью транзакции. Если запущен вне транзакции, то в нем стартует новая транзакция.
    REQUIRES_NEW - если метод запускается внутри транзакции, то она останавливается, запускается новая, отрабатывается, а затем продолжает работу первая.
		Если метод запускается самостоятельно, то просто стартует новая транзакция. Данный модификатор служит для того, что бы быть уверенным, что всегда будет запущена новая транзакция.
    MANDATORY - если метод запущен внутри транзакции, то он является её частью. Если же запускается вне транзакции, то бросается исключение TransactionRequiredException.
    NOT_SUPPORTED - если метод запускается внутри транзакции, то на время работы метода транзакция останавливается, пока не отработается метод, травзакция в которм не стартуетс,
		затем транзакция продолжает работу. Если метод запускается вне транзакции, то транзакция в нем не стартует. Этот атрибут увеличивает производительность, т.к. транзакции связаны с дополнительными нагрузками.
    SUPPORTS - если внутри транзакции, то является частью транзакции, если запускается самостоятельно, то транзакция не стартует.
    NEVER - Если внутри транзакции, то бросается исключение RemoteException, если вне транзакции, то метод запускается без старта транзакции.

	http://sh2533.blogspot.com/2011/07/ejb.html

 
===================================
===================================

# java.util.concurrent.*
ArrayBlockingQueue, ConcurrentHashMap, AtomicInteger, Collections.synchronizedList(new LinkedList()) и другие интересности.
Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета.
Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков.
Synchronizers — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.
Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.
Создаем ExecutorService exec = Executors.newCachedThreadPool(); Затем передаем методу execute экземпляр нашего класса. В конце вызываем shutdown(), который предотвращает передачу Executor новых задач.
Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.
Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.

Callable используется вместо Runnable для того, что бы задача возвращала значение. Перегруженный метод Executors.callable() получает Runnable и выдает Callable.
Потоки-демоны завершают свои методы run() без выполнения секций finally.
 
===================================
===================================

# Когда поток переходит из нового состояния в работоспособное?
Когда вызывается метод start(), поток переходит из нового состояния в работоспособное.
 Как заставить главный поток ждать завершения побочного?
Чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.
Поток – часть процесса, состоящий из набора команд и имеющий одно адресное пространство. 
Поток создаётся наследованием класса Thread или реализацией интерфейса Runnable.
Запускается поток методом start(), который запускает метод  run(). Если поток был приостановлен, то запустить снова его можно методами notify() и notifyAll(), который запускает все приостановленные потоки. 
Остановить поток можно методом interrupt(). Приостановить его можно методом wait().
Состояния потока: новый, работоспособный, работающий, ожидающий, заблокированный, спящий, мёртвый. 

Поток создаётся либо наследованием от Thread, либо реализацией Runnable.

В Java существуют (существовали) средства для принудительного завершения потока. В частности метод Thread.stop() завершает поток незамедлительно после своего выполнения. Однако этот метод, а также Thread.suspend(), приостанавливающий поток, и Thread.resume(), продолжающий выполнение потока, были объявлены устаревшими и их использование отныне крайне нежелательно. Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке.

===================================
===================================

# Как определить аннотацию на рантайме?
Если необходимо доступ к аннотации в процессе функционирования приложения. То перед объявлением аннотации задается правило сохранения RUNTIME в виде кода:
Import java.lang.annotation.Retention;
Import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
и вызываем на требуемом объекте метод getAnnotation().
 
===================================
===================================

# HashMap.
1.	Сначала ключ проверяется на равенство null. Если это проверка вернула true, будет вызван метод putForNullKey(value) (вариант с добавлением null-ключа рассмотрим чуть позже).
2.	Далее генерируется хэш на основе ключа. Для генерации используется метод hash(hashCode), в который передается key.hashCode().
3.	С помощью метода indexFor(hash, tableLength), определяется позиция в массиве, куда будет помещен элемент.
4.	Теперь, зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается.
5.	Если же предыдущий шаг не выявил совпадений, будет вызван метод addEntry(hash, key, value, index) для добавления нового элемента.
 
===================================
===================================

13. Reflection. JNI.
 Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов. Можно также выполнять операции над полями и методами которые исследуются. Рефлексия в Java осуществляется с помощью Java Reflection API. Этот интерфейс API состоит из классов пакетов java.lang и java.lang.reflect. С помощью интерфейса Java Reflection API можно делать следующее: 
•	Определить класс объекта. 
•	Получить информацию о модификаторах класса, полях, методах, конструкторах и суперклассах.
•	Выяснить, какие константы и методы принадлежат интерфейсу. 
•	Создать экземпляр класса, имя которого неизвестно до момента выполнения программы.
•	Получить и установить значение свойства объекта.
•	Вызвать метод объекта.
•	Создать новый массив, размер и тип компонентов которого неизвестны до момента выполнения программ.
Java Native Interface (JNI) — стандартный механизм для запуска кода, под управлением виртуальной машины Java (JVM), который написан на языках С/С++ или Ассемблера, и скомпонован в виде динамических библиотек, позволяет не использовать статическое связывание. Это даёт возможность вызова функции С/С++ из программы на Java, и наоборот. Более ранние интерфейсы, в отличие от JNI, не удовлетворяли условию двоичной совместимости.
 
===================================
===================================

	16. Что такое API?
Интерфейс программирования приложений (иногда интерфейс прикладного программирования) (англ. application programming interface, API [эй-пи-ай])[1] — набор готовых классов, процедур, функций, структур и констант, предоставляемых приложением (библиотекой, сервисом) для использования во внешних программных продуктах. Используется программистами для написания всевозможных приложений.
API определяет функциональность, которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как именно эта функциональность реализована.
Если программу (модуль, библиотеку) рассматривать как чёрный ящик, то API — это множество «ручек», которые доступны пользователю данного ящика, и которые он может вертеть и дёргать.

===================================
===================================

# Что такое сервер приложений? Что такое веб-сервер, в чём его отличие от сервера приложений? Привести примеры веб-сервера и сервера приложений.
    Сервер приложений  - компонентный сервер, исполняющий приложения для работы с клиентом. Он предоставляет разработчику стандартный фреймворк, контейнер сервлетов итд.
    Веб-сервер – узкоспециализированный сервер, взаимодействующий  с клиентом по протоколу http. Отличается от сервера приложений узкой специализацией.
    Пример веб-сервера  - tomcat, сервера приложений – JBOSS и Glassfish.

===================================
===================================

# Что такое контейнер сервлетов? Что такое сервлет? Методы сервлета.  Жизненный цикл сервлета. 
    Контейнер сервлетов -  программа, управляющая жизненным циклом сервлетов.
    Сервлет – класс, отвечающий за обработку запросов клиента и отправку ответов. Основные методы сервлета: init() – запускается сразу после  загрузки сервлета в память; service() – вызывается для обработки каждого запроса; destroy() – выполняется перед выгрузкой сервлета из памяти.
    Жизненный цикл сервлета: им управляет контейнер сервлетов, при первом обращении к сервлету происходит его загрузка в память и вызывается  метод init(). На протяжении работы приложения происходят вызовы методы service() для обработки запросов клиента. По завершению работы приложения вызывается метод destroy() и сервлет выгружается из памяти.

    При проектировании сервлетов нужно уделить особое внимание тому, чтобы сервлет был thread-safe. Не использовать переменные экземпляра, например. Либо синхронизировать к ним доступ. В общем, рассчитывайте на то, что методы сервлета будут вызываться из разных потоков.

===================================
===================================

# Что такое сессия?
    Это соединение клиента с сервером, устанавливаемой на определённое время, за которое клиент может сделать любое количество запросов к серверу.

===================================
===================================

# Что нужно написать в браузерной строке, чтобы обратиться к сервлету? Можно ли из браузерной строки напрямую вызвать метод сервлета?
    Надо написать маппинг сервлета. Метод напрямую вызвать нельзя.

===================================
===================================

# Что такое JSP? Жизненный цикл jsp.
    JSP – веб-страница, представляющая собой комбинацию статического html и java-кода. 
    Жизненный цикл JSP. Исходный код jsp, к которой идёт запрос от клиента, анализируется и парсится jsp_engine, далее создаётся временный сервлет, основанный на коде jsp. Далее сервлет компилируется. Запускаются методы init() и jsp_service(). После обработки методом jsp_service() отсылается ответ клиенту в виде html.

===================================
===================================

# Чем отличаются методы GET и POST? Если не указать напрямую, какой из этих методов выполнится по умолчанию. 
    При использовании метода POST данные передаются в зашифрованном виде. В GET есть ограничение на размер передаваемой в запросе строки.
    По умолчанию выполняется GET.

===================================
===================================

# Какие области памяти использует java для размещения простых типов, объектов, функций и.т.д.? 
	Для размещения простых типов и методов java использует стек, для объектов – кучу (heap).

===================================
===================================

# Транзакции, что такое, для чего используются? Уровни изолированности транзакций. Привести примеры использования.
	Транзакция – несколько операций, выполняемых как одна, либо не выполняемые совсем.
	Используется для запросов к БД, исключающих потерю данных и некорректное взаимодействие с БД. Смысл в том, что если происходит ошибка на этапе выполнения одной из операций, то результат всех операций будет отменён.
	Уровни изолированности:
		Serializable – исключаются все виды ошибок.
		Repeatable read – исключаются все виды ошибок, кроме фантомного чтения.
		Read committed – исключается потеря обновления и грязное чтение. 
		Read uncommitted – исключается только потеря обновлений.
		Пример использования – банковская система: снятие денег со счёта и выдача их клиенту должна проходить как единое действие, поэтому используется транзакция. 

===================================
===================================

# Как сделать запросы к базе данных через jdbc.  Перечислите все этапы. Чем отличается Statement от PreparedStatement? Где сохраняется запрос после первого вызова PreparedStatement? Зачем нужен CallableStatement?
 	Создаётся соединение (либо берётся из пула), создаётся запрос (либо подготавливается), выполняется запрос.
	PreparedStatement не допускает инъекций и при большом количестве запросов, отличающихся только параметрами, даёт лучшую производительность. После первого вызова PreparedStatement сохраняется в кэше СУБД. Обратно возвращается его id и количество параметров. При его выполнении драйвер передаёт в СУБД только id и параметры, а СУБД находит соответствующий запрос, подставляет параметры и выполняет его.  При последующих вызовах этого prepared, СУБД просто находит уже созданный запрос и возвращает его id.
	CallableStatement нужен для вызова хранимых процедур.

===================================
===================================

# Каким требованиям должен отвечать xml-документ, чтобы называться well-formed? В чём отличие между понятиями well-formed и valid?
	Well-formed документ должен соответствовать синтаксису xml.
	Valid, в отличие от well-formed, должен соответствовать  схеме.

DOM – создаёт полную древовидную модель xml-документа. Позволяет изменять данные в xml-документе. Применяется, когда нужно получить все данные или внести изменения.
SAX – основана на обработке событий, позволяет извлечь отдельные данные не извлекая остальные.
StAX – работает по тому же принципу, что и SAX. Отличие состоит в том, что разработчик сам указывает, когда перейти к следующему элементу.


===================================
===================================

# Что такое синхронизация? Что такое deadlock? Какие методы синхронизации вы знаете? Для чего нужно ключевое слово synchronized? Для чего применяется ключевое слово volatile?
Синхронизация – обеспечение безопасного взаимодействия нескольких потоков с одним и тем же ресурсом.
deadlock – взаимная блокировка – ситуация, когда один поток взаимодействует с первым ресурсом, блокирует его, и пытается обратиться к другому ресурсу, который используется другим потоком, также блокирующим его. Причём  второй поток пытается обратиться к первому ресурсу. Таким образом, первый поток ждёт освобождения второго ресурса, а второй поток – первого ресурса.
Методы синхронизации: synchronized (синхронизировать метод, синхронизировать блок), использовать concurrent, использовать lock.
synchronized используется, чтобы указать, что данный метод или блок синхронизирован.
volatile используется для того, чтобы объявить переменную, изменения которой в одном потоке будут видны во всех.

Хочу еще разграничить два понятия – поток и процесс. Процесс – это задача операционной системы. У него собственное адресное пространство. С ним может быть проассоциировано несколько потоков. Поток же – это гораздо более мелкая единица. Все потоки разделяют адресное пространство породившего их процесса и имеют доступ к одним данным.
Существует два пути создания потока. Первый – наследование от класса java.lang.Thread и переопределение его метода run. Второй – реализация интерфейса java.lang.Runnable и создание потока на основе этой реализации. В принципе это методы эквивалентны, разница в деталях. Наследование от java.lang.Thread делает его единственным родителем класса, что не всегда удобно. Я лично предпочитаю реализовывать java.lang.Runnable.
В приведенных примерах в методах main создаются потоки, после чего они запускаются на выполнение. Поток завершается, когда произошел выход из метода run, либо если в методе run было выброшено исключение, которое не было обработано. Чаще всего это RuntimeException или наследник, реже – Error или наследник. После того, как поток завершил работу, перестартовать его НЕЛЬЗЯ. Попытка вторичного вызова start приведет к исключению IllegalThreadStateException.

Для того, чтобы уже закончить с классом Thread, коснемся еще нескольких его возможностей.
- Во-первых, у потоков могут быть различные приоритеты. Существует несколько констант – Thread.MIN_PRIORITY == 1, Thread.NORM_PRIORITY == 5 и Thread.MAX_PRIORITY == 10. Значения эти внутренние и с реальными приоритетами потоков в операционной системе соотносятся слабо.
- Во-вторых, потоки могу быть т.н. демонами. Такой поток отличается от обычного тем, что он не препятствует окончанию работы виртуальной машины. Т.е. можно сказать, что виртуальная машина работает, пока существует хотя бы один поток, не являющийся демоном. Потоки-демоны удобно использовать для фоновых задач.
- В-третьих, поток можно приостановить на определенный промежуток времени. Изнутри. Делается это через статический метод Thread.sleep() с параметром – количеством миллисекунд, на которое приостанавливается поток. До истечения этого времени поток может быть выведен из состояния ожидания вызовом interrupt, о котором мы поговорим в следующей части.
- И последнее, чего бы я тут хотел коснуться – статический метод yield. Он служит для передачи управления другим потокам. Т.е. в результате его вызова происходит переключение контекста и процессор начинает исполнять код другого потока. Это нужно как в ситуациях, когда работа на текущий момент завершена и можно дать поработать другим (например, поток обрабатывает данные, все обработал, а новые еще не пришли), так и в ситуациях, когда поток занимается какими-нибудь интенсивными действиями, съедает большую часть процессора и не дает другим потокам работать. Правда, последний подход я встречал только в программировании под Java ME, в условиях ограниченных ресурсов. Обратите внимание, что этот метод статический и действует только на текущий поток. Заставить таким образом чужой поток поделиться своим временем нельзя!

На данный момент мы знаем, как запустить поток на выполнение. Естественный вопрос – а как его остановить? Ответ может оказаться обескураживающим. В Java НЕТ средств для принудительной остановки потока. Вернее, они есть, но использовать их не стоит – метод stop объявлен deprecated. А вместе с ним – и suspend c resume.
Почему это так сделано? Причины, несомненно, есть. Дело в том, что при принудительной остановке (приостановке) потока совершенно непонятно, что делать с ресурсами. Поток может открыть сетевое соединение, например. Что делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? То же самое и про соединение с базой данных. И еще много про что. А если поток остановят посередине транзакции? Кто ее будет закрывать? Кто будет разблокировать ресурсы? В общем, проблем тут существенно больше, чем преимуществ.
Потому – в Java принят уведомительный порядок остановки потока. Вариантов реализации два: либо воспользоваться существующими механизмами, либо создавать такие механизмы вручную. Мы рассмотрим оба варианта и проблемы, связаные с ними.

Вариант первый – использовать существующий механизм. У класса Thread есть такой метод – interrupt. Этот метод выставляет некоторый флаг в дебрях native-кода. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted. Существует также статический метод interrupted, который производит проверку для текущего потока. Обратите внимание – вызов этого метода сбрасывает флаг, что подразумевает ответственность разработчика по обработке этой ситуации.
Что хорошо в методе interrupt? Он способен вывести поток из состояния ожидания. Т.е. если у потока были вызваны методы sleep или wait (мы поговорим о нем ниже) – ожидание прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется, т.к. на брошеное исключение разработчик отреагирует незамедлительно.
Таким образом, действовать нужно так. Реализуете поток (удобнее через наследование от Thread). В потоке периодически вставляете проверки isInterrupted. Если проверка сработала или выброшено исключение во время ожидания – поток пытаются остановить извне. Обращаю внимание – именно остановить, а не ПРИостановить. Вам надо принять решение – либо вы продолжаете работу (если по каким-то причинам не можете остановиться), либо вы освобождаете ресурсы и выходите из метода run. Что вы выберете – зависит от ситуации. Главное – у вас есть возможность маневрировать и делать то, что сочтете нужным. В том числе и продолжать работу. В случае вызова stop такой возможности нет.

Любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (на который он может сослаться как на this). Если это удалось – метод исполняется. Если нет – поток останавливается и ждет, пока монитор будет отпущен.

Итак, резюме. Если два нестатических метода объявлены как synchronized, то в каждый момент времени из разных потоков на одном объекте может быть вызван только один из них. Поток, который вызывает метод первым, захватит монитор, и второму потоку придется ждать. Заостряю ваше внимание на трех моментах:
- Это верно только для разных потоков. Один и тот же поток может вызвать синхронизированный метод, внутри него – другой синхронизированный метод на том же экземпляре. Поскольку этот поток владеет монитором, проблем второй вызов не создаст.
- Это верно только для вызовов методов одного экземпляра. У разных экземпляров разные мониторы, потому одновременный вызов нестатических методов проблем не создаст
- В случае статических методов имеет значение только одно – разные ли потоки, вызывающие синхронизированные методы, или нет. Об экземпляре тут речи не идет, его роль исполняет объект класса.

===================================
===================================

# Что такое сериализация, для чего нужна, когда используется? Ключевое слово transient, для чего нужно?
Сериализация – запись объекта в поток. Нужна для передачи данных между разными слоями приложения. Используется, к примеру, когда на jsp надо использовать JavaBean. 
transient указывает на то, что данная переменная не будет сериализована, а при десериализации  ей будет присвоено значение null или 0, если тип базовый.

Существуют 2 способа сериализации. Первый - реализация java.io.Serializable, не требующая никаких усилий. Второй способ – это тоже реализация интерфейса, но уже другого: java.io.Externalizable. В отличие от java.io.Serializable, он содержит два метода, которые необходимо реализовать – writeExternal(ObjectOutput) и readExternal(ObjectInput). В этих методах как раз и находится логика сериализации/десериализации.
Между упомянутыми двумя способами сериализации существует еще одно серьезное отличие. А именно – в механизме десериализации. При использовании Serializable десериализация происходит так: под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается.

То есть при десериализации вызывается конструктор без параметров родительского НЕсериализуемого класса. И если такого конструктора не будет – при десериализации возникнет ошибка. Конструктор же дочернего объекта, того, который мы десериализуем, не вызывается, как и было сказано выше.

Так ведут себя стандартные механизмы при использовании Serializable. При использовании же Externalizable ситуация иная. Сначала вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal, который и вычитывает, собственно, все свои данные. Потому – любой реализующий интерфейс Externalizable класс обязан иметь public конструктор без параметров! Более того, поскольку все наследники такого класса тоже будут считаться реализующими интерфейс Externalizable, у них тоже должен быть конструктор без параметров!
Последний момент – наследование. При наследовании от класса, реализующего Serializable, никаких дополнительных действий предпринимать не надо. Сериализация будет распространяться и на дочерний класс. При наследовании от класса, реализующего Externalizable, необходимо переопределить методы родительского класса readExternal и writeExternal. Иначе поля дочернего класса сериализованы не будут. В этом случае надо бы не забыть вызвать родительские методы, иначе не сериализованы будут уже родительские поля.

Правило 1. После десериализации объекта необходимо проверить его внутреннее состояние (инварианты) на правильность, точно так же, как и при создании с помощью конструктора. Если объект не прошел такую проверку, необходимо инициировать исключение java.io.InvalidObjectException.
Правило 2. Если в составе класса A присутствуют объекты, которые не должны быть доступными для изменения извне, то при десериализации экземпляра класса A необходимо вместо этих объектов создать и сохранить их копии.


===================================
===================================

# Что нужно написать в строке браузера, чтобы обратиться к хосту, на котором установлен томкат, развёрнуто приложение, в котором есть несколько сервлетов? Как обратится к конкретному сервлету?
В строке браузера пишется ip-aдрес хоста, номер порта, имя приложения и маппинг сервлета.

===================================
===================================

# Применение классов HttpServletRequestWrapper и HttpServletResponseWrapper.
С помощью этих классов можно изменять запрос и ответ соответственно.

===================================
===================================

# какой последовательности выполняются сервлет фильтры?
В той последовательности, в которой они заданы в FilterChain.

===================================
===================================

# Работа с JSTL тегами.
JSTL позволяет не использовать java код на jsp страницах. В JSTL используется expression language для упрощения доступа к данным, хранящимся в различных областях видимости (page, request, session, application ).
Основные jstl-теги: out,set,remove,if,choose,redirect, import, forEach итд.

===================================
===================================

# Как обрабатывается тег с телом?
Есть методы doStartTag(), doEndTag(), doInitBody(), doAfterBody(), которые запускаются при срабатывании соответствующего события. В них заключается обработка данных, переданных в тег, и вывод результата.

===================================
===================================

# Кодировки
- Прямоугольники вместо символов. Причем в количестве, равном количеству символов. Причина, скорее всего, банальна – шрифт просто не содержит символов, которые мы хотим им отобразить. Ибо очень многие компоненты используют системные шрифты, которые чаще всего локализованы и не содержат, скажем, азиатских иероглифов. Декодирование же входного потока байтов скорее всего было успешным. Так что в этом случае рецепт довольно прост. Установить компоненте Unicode-шрифт, если проблема ушла – искать легальные пути решения (ибо Unicode-шрифтов очень мало и они, как правило, имеют разные имена в разных системах). Возможно, существуют и другие ситуации, когда символы замещаются прямоугольниками, но я с ними не сталкивался.
- Второй тип проблем – вопросительные знаки вместо символов. Скорее всего причина в ошибке при декодировании входного потока. Такое бывает, к примеру, при попытке прочитать текст в кодировке windows-1251 с использованием кодировки UTF-8.
- Третий тип проблем – символы есть, но не те. Тоже весьма распространенная ситуация. Символов может быть существенно больше (иногда – раза в три), определенные символы могут встречаться достаточно часто. Нелогичных вопросительных знаков нет – значит, декодер не нашел ошибок. Символы отображаются – значит, они есть в шрифте. Символов существенно больше чем нужно, многие регулярно повторяются. На что это похоже? А похоже это на попытку расценить несколько-(в данном случае – двух, судя по регулярности появления одинаковых символов)-байтовую кодировку как однобайтовую. Скажем, русский текст, записаный в кодировке UTF-8, прочитали с использованием схемы кодировки windows-1251. Кодировка эта однобайтовая, схема тривиальна – декодер каждый байт воспринимает как символ.

Кодировку надо учитывать как во время компиляции, так и при выводе на консоль. Невыполнение этого правила в любом из двух мест способно вызвать проблемы.

Для того, чтобы исключить проблемы с кодировками при компиляции и консольном выводе, необходимо:
- В явном виде указать компилятору кодировку исходника – с помощью опции -encoding или же каким-либо другим способом (в ant и maven есть свои настройки, в средах разработки также можно указать кодировку исходников)
- В явном виде установить кодировку консоли с помощью вызова:
	System.setOut(new java.io.PrintStream(System.out, true, "<имя кодировки>"));

===================================
===================================

# ЛОКАЛИЗАЦИЯ
Это означает, например, отказ от использования непосредственно в коде сообщений, форматов и т.п. – всего, что может зависеть от языка. Этот процесс называется internationalization, сокращается это слово как i18n (по причине того, что между "i" и "n" в этом длинном слове 18 букв). Второй процесс – создание набора ресурсов для полного перевода приложения на другой язык. Этот процесс зовется localization, и сокращается как l10n.
Существует понятие т.н. "географического региона" – locale. Оно представлено в виде объекта типа java.util.Locale и характеризуется языком, страной и т.н. вариантом (разновидностью) языка. Именно в таком порядке, язык имеет приоритет над страной. Это несколько странно в свете названия locale (дословно – "место действия"), но позволяет использовать эти объекты для идентификации языка. Что весьма удобно при переводе приложений.
Далее. Ресурсы сосредоточены в т.н. ResourceBundle. Существует механизм поиска ResourceBundle, соответствующего необходимому языку (здесь и далее я буду употреблять язык для обозначения locale, ибо лучшего эквивалента найти не могу). Пакеты (bundle) ресурсов определяются по имени. Ресурсы в них – по строковым ключам.

===================================
===================================

# ВНУТРЕННИЕ (INNER) КЛАССЫ
Нестатические вложенные классы принято называть внутренними (inner) классами. Доступ к элементам внутреннего класса возможен из внешнего класса только через объект внутреннего класса, который должен быть создан в коде метода внешнего класса. Объект внутреннего класса всегда ассоциируется (скрыто хранит ссылку) с создавшим его объектом внешнего класса – так называемым внешним (enclosing) объектом.
Как правило, внешний класс содержит метод, возвращающий ссылку на внутренний класс.
Объект внутреннего класса связан с внешним объектом-создателем и может обращаться к его членам без каких-либо дополнительных описаний. Вдобавок для внутренних классов доступны все без исключения элементы внешнего класса.
Если вам понадобится получить ссылку на объект внешнего класса, запишите имя вненего класса, за которым следует точка, а зате ключевое слово this. полученная сылка автоматически относится к правильному типу, известному и проверяемому на стадии компиляции, поэтому дополнительные издержки на стадии выполнения не требуются.
Невозможно создать объект внутреннего класса, не имея ссылки на внешний класс. Но если создать вложенный класс (статический внутренний класс), ссылка на объект внешнего класса не нужна.
Локальный внутренний класс созадется в контексте метода.
Если вы определите безымянный внутренний класс и хотите при этом использовать объекты, определенные вне этого внутреннего класса, компилятор требует, чтобы переданные на них ссылки объявлялись неизменными (final). Без такого объявления вы получите сообщение об ошибке при комплияции программы.

Почему нельзя передать не-final переменную в анонимный класс?
Можно, если мы не будем использовать ее напрямую внутри безымянного класса. Переменные должны быть объявлены final, что бы их можно было использовать внутри безымянного класса. 

ВЛОЖЕННЫЕ КЛАССЫ
Если свзяь между объктом внутреннего класса и объъектом внешнего класса не нужна, можно сделать внутренний класс статическим. Часто такой класс называют вложенным (nested). В объекте обычного внутреннего класса тайно хранится ссылка на объект создавшего его объемлющего внешнего класса. При использовании статического внутреннго класса такой ссылки не существует. Применение статического внутреннего класса означает следующее:
- для создания объекта статического внутреннего класса не нужен объект внешнего класса;
- из объекта вложенного класса нельзя обращаться к не-статическим членам внешнего класса.
Поля и методы обычного внутреннего класса определяются только на уровне внешнего класса, поэтому обычные внутренние классы не могут содержать статические данные, поля и классы. Но вложенные классы не имеют таких ограничений.

Независимо от глубины вложенности, внутренний класс всегда может напрямую обращаться ко всем членам всех классов, в которые он встроен.

Каждый внутренний класс способен независимо наследовать определенную реализацию. Таким образом, внутренний класс не ограничен при наследовании в ситуациях, где внешний класс уже наследует реализацию.
Внутренний класс выступает как "довесок" решения проблемы множественного наследования. Интерфейсы берут на себя часть этой задачи, тогда как внутренние классы фактически обеспечивают "множественное наследование реализации". Другими словами, внутренние классы позволяют наследовать от несколькоих не-интерфейсов.

- У внутреннего класса может существовать произвольное количество экземпляров, каждый из которых обладает собственной информацией состояния, не зависящей от состояния объекта внешнего класса.
- Один внешний класс может содержать несколько внутренних классов, по-разному реализующих один и тот же интерфейс или наследующих от единого базового класса.
- Место созадния объекта внутреннего класса не привязано к месту и времени создания объекта вншнего класса.
- Внутренний класс не использует тип отношений классов "является тем-то", способных вызвать недоразуменя; он представляет собой отдельную сущность.

Можно ли переопределить внутренний класс? Это было бы довольно интересно, но "переопределение" внутреннего класса, как если бы он был еще одним методом внешнего класса, фактически не имеет никакого эффекта. 

===================================
===================================

# КОМПОЗИЦИЯ
Композиция - механизм построения нового класса из объектов существующих классов. Просто используется функциональность готового кода, а не его структура. Композиция в основном применяется, когда в новом классе необходимо использовать функциональность уже существующего класса, но не его интерфейс. То есть вы встраиваете объект, чтобы использовать его возможности в новом классе, а пользователь класса видит определенный вами интерфейс, но не замечает встроенных объектов. Для этого внедряемые объекты объявляются со спецификатором private. 

===================================
===================================

# ИТЕРАТОРЫ
Итератор - это объект, обеспечивающий перемещение по последовательности объектов с выбором каждого объекта этой последовательности, при это программисту-клиенту не надо знать или заботиться о лежащей в ее основе структуре. Вдобавок, итератор обычно является так называемым "легковесным" объектом: его создание должно обходиться без заметных затрат ресурсов. Из-за этого итераторы часто имеют ограничения; Iterator в Java поддерживает перемещение только в одном направлении. С его возможностью можно сделать следующее:
- Запросить у контейнера итератор вызовом метода iterator(). Полученный итератор готов вернуть начальный элемент последовательности при первом вызове своего метода next().
- Получить следующий элемент последовательности вызовом метода next().
- Проверить, остались ли еще объекты в последовательности (метод hasNext()).
- Удалить из последовательности последний элемент, возвращенный итератором, метдом remove().

ListIterator - более мощная разновидность Iterator, поддерживаемая только классами List. Он является двусторонним. Так же он может выдавать индексы следующего и предыдущего элементов по отношению к текущей позиции. Заменять последний посещенный элемент методом set(). Вызов listIterator() возвращает итератор в начало листа, а с listIterator(n) возвращает итератор в позицию n.

===================================
===================================

# ОТЛИЧИЕ MAVEN ОТ ANT
ANT - гибкий инструмент скриптового типа. Имеет большое количество реализованных "команд", которые можно включать в любом количестве и любом порядке в т.н. задачи. Задачи тоже могут иметь зависимости, при этом ant сортирует весь граф зависимостей и выполняет задачи в гарантированно правильном порядке.
Те команды, которые требуют использования classpath, имеют теги, позволяющие этот classpath указать. Можно указывать директории с классами, jar-файлы, директории, содержащие jar-файлы.
При отсутствии нужной команды можно ее написать - API легко расширяем.

MAVEN - достаточно жесткий сборщик. Инструмент заточен под сборку программного продукта, написанного на Java. Имеет несколько жизненных циклов - default (сборочный), site и clean. Каждый жизненный цикл имеет предопределенные фазы, к которым можно привязывать выполнение плагинов.
classpath формируется автоматически. Сборочный скрипт содержит секцию зависимостей, в которой указываются все необходимые библиотеки с версиями. Библиотеки берутся из репозитория. В репозитории вместе с библиотеками хранятся их описатели, в которых указаны уже зависимости библиотек.
Таким образом, maven позволяет указать только те зависимости, которые нужны Вам в коде. При правильно указаном репозитории (или репозиториях) все библиотеки автоматически будут скачаны вместе со всеми зависимостями. Собственно, это одна из ключевых особенностей maven.
MAVEN хорош, когда Вам нужно сделать типовую задачу - собрать приложение, сгенерировать по нему документацию. Когда нужно что-то более сложное - мы писали ant-скрипт и вызывали его из maven-а.

===================================
===================================

Концепция нескольких объектов, "упакованных" в один объект, называется кортежем (tuple). Получатель объекта может читать элементы, но не может добавлять их (эта концепция еще называется объектом предеачи данных).
Если возможно параметризовать метод вместо целого класса, вероятно, стоит выбрать именно этот вариант. Кроме того, счатические методы не имеют доступа к параметрам типа парметризованных классов; если такие методы должны исползовать параметризацию, это должно проиходить на уровне метода, а не на уровне класса.
Класс и метод могу быть параметризованы вместе либо кто-то один из них.

===================================
===================================

Java SE — стандартная версия платформы Java 2, предназначенная для создания и исполнения апплетов и приложений, рассчитанных на индивидуальное пользование или на использование в масштабах малого предприятия. Не включает в себя многие возможности, предоставляемые более мощной и расширенной платформой Java 2 Enterprise Edition (J2EE), рассчитанной на создание коммерческих приложений масштаба крупных и средних предприятий.

Java EE - набор спецификаций и соответствующей документации для языка Java, описывающей архитектуру серверной платформы для задач средних и крупных предприятий.
JEE является промышленной технологией и в основном используется в высокопроизводительных проектах, в которых необходима надежность, масштабируемость, гибкость.
Популярности JEE также способствует то, что Sun предлагает бесплатный комплект разработки, SDK, позволяющий предприятиям разрабатывать свои системы, не тратя больших средств. В этот комплект входит сервер приложений GlassFish с лицензией для разработки.

Java EE включает в себя стандарты следующих технологий:
EJB - Enterprise JavaBeans — спецификация технологии серверных компонентов, содержащих бизнес-логику
JPA - Java Persistence API
Сервлет - Обслуживание запросов веб-клиентов
JSP - JavaServer Pages — динамическая генерация веб-страниц на стороне сервера
JSTL - JavaServer Pages Standard Tag Library
JSF - JavaServer Faces — компонентный серверный фреймворк для разработки веб-приложений на технологии Java
JAX-WS - Java API for XML Web Services — создание веб-сервисов
JAX-RS - Java API for RESTful Web Services — создание RESTful веб-сервисов
JNDI - Java Naming and Directory Interface — служба каталогов
JMS - Java Message Service — обмен сообщениями
JTA - Java Transaction API
JAAS - Java Authentication and Authorization Service — Java-реализация PAM
JavaMail - Получение и отправка электронной почты
JACC - Java Authorization Contract for Containers
JCA - J2EE Connector Architecture
JAF - JavaBeans Activation Framework
StAX - Streaming API for XML
CDI - Context and Dependency Injection

===================================
===================================



===================================
===================================

===================================
===================================

===================================
===================================

# Аксиомы программирования
	- Если есть возможность воспользоваться чужим опытом – изучи ее.
	- Если ты не понимаешь, что делаешь – делай это тщательно.
	- Программный код должен читаться легче, чем писаться.
	- Качественным является код, максимально приспособленный к поддержке.

В проектировании приложения есть числа 1 и 0. Что означает, что компонент приложения либо есть, либо его нет. В случае возможного присутствия хотя бы двух одинаковых компонентов, стоит считать, что их может быть неопределенное число N и, соответственно, основывать бизнес-логику именно на этом предположении.

Константа есть отражение нашего предположения о том, что некоторая величина имеет заранее определенное постоянное значение.

XP как методология предназначена для уменьшения затрат на разработку и поддержку ПО. При этом она обеспечивает гибкость процесса разработки, качество продукта и его соответствие реальным потребностям заказчика.
...каждая команда должна выбрать наиболее подходящий ей процесс и активно изменять его, подстраивая под нужды конкретного проекта.

В основе существования команды лежат четыре принципа – доверие, равенство, уважение и поддержка.
Лидер – это
а) полноправный член команды,
б) ведущий команду за собой,
в) принимающий решения, направленные на наиболее эффективное достижение цели команды.

В конечном итоге все эти возражения упираются в отсутствие (и даже неприятие!) командных ценностей – доверия, равенства, уважения, поддержки и ответственности. Все эти составляющие жизненно необходимы для успешной реализации практики коллективного владения кодом:

Доверие – я доверяю членам моей команды в том, что они не повесят на меня ответственность за свои ошибки
Равенство – я исправляю любой код, вне зависимости от авторства
Уважение – я уважаю членов команды, поэтому исправляю свои ошибки сам
Поддержка – я исправляю чужие ошибки: мне это несложно, а товарищу по команде – помощь
Ответственность – я отвечаю за свои действия и ошибки





# Даны 2 таблицы: Employee (id_employee, salary, department_id_fk); Department (id_department, department_name). Написать sql-запрос, который выберет названия отделов, суммарная зарплата сотрудников в которых больше 1000. 
	select department_name from Department as dep
	join Employee as emp on dep.id_department=emp.id_employee
	group by dep.department_name
	having sum(eml.salary)>1000


















