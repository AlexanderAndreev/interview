
Inversion of Control (инверсия управления) — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода.
Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.
Dependency Injection (внедрение зависимостей) — это одна из реализаций этого принципа (помимо этого есть еще Factory Method, Service Locator). Еще одна реализация - паттерн Фабрика
Формулировка:
- Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции.
- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
 
===================================
===================================

Spring. BeanFactory - это базовый интерфейс. Самые начальные его реализации передают например путь к xml (или даже properties) конфигурации и дальше можно доставтаь бины.
Продвинутая реализация ApplicationContext - она с поддержкой транзакций, AOP, обрабботка событий и тд. 
http://j4sq.blogspot.com/2012/01/java-spring-hibernate.html
 
===================================
===================================

REST - это архитектурный стиль, стандарт для создания веб сервисов. REST - метод взаимодействия компонентов распределённого приложения в сети Интернет, при котором вызов удаленной процедуры представляет собой обычный HTTP-запрос (обычно GET или POST; такой запрос называют REST-запрос), а необходимые данные передаются в качестве параметров запроса.
RESTFull - набор АПИ, которые следуют стилю REST

===================================
===================================

# Как определить аннотацию на рантайме?
Если необходимо доступ к аннотации в процессе функционирования приложения. То перед объявлением аннотации задается правило сохранения RUNTIME в виде кода:
Import java.lang.annotation.Retention;
Import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
и вызываем на требуемом объекте метод getAnnotation().
 
===================================
===================================

13. Reflection. JNI.
 Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов. Можно также выполнять операции над полями и методами которые исследуются. Рефлексия в Java осуществляется с помощью Java Reflection API. Этот интерфейс API состоит из классов пакетов java.lang и java.lang.reflect. С помощью интерфейса Java Reflection API можно делать следующее: 
•	Определить класс объекта. 
•	Получить информацию о модификаторах класса, полях, методах, конструкторах и суперклассах.
•	Выяснить, какие константы и методы принадлежат интерфейсу. 
•	Создать экземпляр класса, имя которого неизвестно до момента выполнения программы.
•	Получить и установить значение свойства объекта.
•	Вызвать метод объекта.
•	Создать новый массив, размер и тип компонентов которого неизвестны до момента выполнения программ.
Java Native Interface (JNI) — стандартный механизм для запуска кода, под управлением виртуальной машины Java (JVM), который написан на языках С/С++ или Ассемблера, и скомпонован в виде динамических библиотек, позволяет не использовать статическое связывание. Это даёт возможность вызова функции С/С++ из программы на Java, и наоборот. Более ранние интерфейсы, в отличие от JNI, не удовлетворяли условию двоичной совместимости.
 
===================================
===================================

	16. Что такое API?
Интерфейс программирования приложений (иногда интерфейс прикладного программирования) (англ. application programming interface, API [эй-пи-ай])[1] — набор готовых классов, процедур, функций, структур и констант, предоставляемых приложением (библиотекой, сервисом) для использования во внешних программных продуктах. Используется программистами для написания всевозможных приложений.
API определяет функциональность, которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как именно эта функциональность реализована.
Если программу (модуль, библиотеку) рассматривать как чёрный ящик, то API — это множество «ручек», которые доступны пользователю данного ящика, и которые он может вертеть и дёргать.

===================================
===================================

# Какие области памяти использует java для размещения простых типов, объектов, функций и.т.д.? 
	Для размещения простых типов и методов java использует стек, для объектов – кучу (heap).

===================================
===================================



===================================
===================================

# Кодировки
- Прямоугольники вместо символов. Причем в количестве, равном количеству символов. Причина, скорее всего, банальна – шрифт просто не содержит символов, которые мы хотим им отобразить. Ибо очень многие компоненты используют системные шрифты, которые чаще всего локализованы и не содержат, скажем, азиатских иероглифов. Декодирование же входного потока байтов скорее всего было успешным. Так что в этом случае рецепт довольно прост. Установить компоненте Unicode-шрифт, если проблема ушла – искать легальные пути решения (ибо Unicode-шрифтов очень мало и они, как правило, имеют разные имена в разных системах). Возможно, существуют и другие ситуации, когда символы замещаются прямоугольниками, но я с ними не сталкивался.
- Второй тип проблем – вопросительные знаки вместо символов. Скорее всего причина в ошибке при декодировании входного потока. Такое бывает, к примеру, при попытке прочитать текст в кодировке windows-1251 с использованием кодировки UTF-8.
- Третий тип проблем – символы есть, но не те. Тоже весьма распространенная ситуация. Символов может быть существенно больше (иногда – раза в три), определенные символы могут встречаться достаточно часто. Нелогичных вопросительных знаков нет – значит, декодер не нашел ошибок. Символы отображаются – значит, они есть в шрифте. Символов существенно больше чем нужно, многие регулярно повторяются. На что это похоже? А похоже это на попытку расценить несколько-(в данном случае – двух, судя по регулярности появления одинаковых символов)-байтовую кодировку как однобайтовую. Скажем, русский текст, записаный в кодировке UTF-8, прочитали с использованием схемы кодировки windows-1251. Кодировка эта однобайтовая, схема тривиальна – декодер каждый байт воспринимает как символ.

Кодировку надо учитывать как во время компиляции, так и при выводе на консоль. Невыполнение этого правила в любом из двух мест способно вызвать проблемы.

Для того, чтобы исключить проблемы с кодировками при компиляции и консольном выводе, необходимо:
- В явном виде указать компилятору кодировку исходника – с помощью опции -encoding или же каким-либо другим способом (в ant и maven есть свои настройки, в средах разработки также можно указать кодировку исходников)
- В явном виде установить кодировку консоли с помощью вызова:
	System.setOut(new java.io.PrintStream(System.out, true, "<имя кодировки>"));

===================================
===================================

# ЛОКАЛИЗАЦИЯ
Это означает, например, отказ от использования непосредственно в коде сообщений, форматов и т.п. – всего, что может зависеть от языка. Этот процесс называется internationalization, сокращается это слово как i18n (по причине того, что между "i" и "n" в этом длинном слове 18 букв). Второй процесс – создание набора ресурсов для полного перевода приложения на другой язык. Этот процесс зовется localization, и сокращается как l10n.
Существует понятие т.н. "географического региона" – locale. Оно представлено в виде объекта типа java.util.Locale и характеризуется языком, страной и т.н. вариантом (разновидностью) языка. Именно в таком порядке, язык имеет приоритет над страной. Это несколько странно в свете названия locale (дословно – "место действия"), но позволяет использовать эти объекты для идентификации языка. Что весьма удобно при переводе приложений.
Далее. Ресурсы сосредоточены в т.н. ResourceBundle. Существует механизм поиска ResourceBundle, соответствующего необходимому языку (здесь и далее я буду употреблять язык для обозначения locale, ибо лучшего эквивалента найти не могу). Пакеты (bundle) ресурсов определяются по имени. Ресурсы в них – по строковым ключам.

===================================
===================================

# ВНУТРЕННИЕ (INNER) КЛАССЫ
Нестатические вложенные классы принято называть внутренними (inner) классами. Доступ к элементам внутреннего класса возможен из внешнего класса только через объект внутреннего класса, который должен быть создан в коде метода внешнего класса. Объект внутреннего класса всегда ассоциируется (скрыто хранит ссылку) с создавшим его объектом внешнего класса – так называемым внешним (enclosing) объектом.
Как правило, внешний класс содержит метод, возвращающий ссылку на внутренний класс.
Объект внутреннего класса связан с внешним объектом-создателем и может обращаться к его членам без каких-либо дополнительных описаний. Вдобавок для внутренних классов доступны все без исключения элементы внешнего класса.
Если вам понадобится получить ссылку на объект внешнего класса, запишите имя вненего класса, за которым следует точка, а зате ключевое слово this. полученная сылка автоматически относится к правильному типу, известному и проверяемому на стадии компиляции, поэтому дополнительные издержки на стадии выполнения не требуются.
Невозможно создать объект внутреннего класса, не имея ссылки на внешний класс. Но если создать вложенный класс (статический внутренний класс), ссылка на объект внешнего класса не нужна.
Локальный внутренний класс созадется в контексте метода.
Если вы определите безымянный внутренний класс и хотите при этом использовать объекты, определенные вне этого внутреннего класса, компилятор требует, чтобы переданные на них ссылки объявлялись неизменными (final). Без такого объявления вы получите сообщение об ошибке при комплияции программы.

Почему нельзя передать не-final переменную в анонимный класс?
Можно, если мы не будем использовать ее напрямую внутри безымянного класса. Переменные должны быть объявлены final, что бы их можно было использовать внутри безымянного класса. 

ВЛОЖЕННЫЕ КЛАССЫ
Если свзяь между объктом внутреннего класса и объъектом внешнего класса не нужна, можно сделать внутренний класс статическим. Часто такой класс называют вложенным (nested). В объекте обычного внутреннего класса тайно хранится ссылка на объект создавшего его объемлющего внешнего класса. При использовании статического внутреннго класса такой ссылки не существует. Применение статического внутреннего класса означает следующее:
- для создания объекта статического внутреннего класса не нужен объект внешнего класса;
- из объекта вложенного класса нельзя обращаться к не-статическим членам внешнего класса.
Поля и методы обычного внутреннего класса определяются только на уровне внешнего класса, поэтому обычные внутренние классы не могут содержать статические данные, поля и классы. Но вложенные классы не имеют таких ограничений.

Независимо от глубины вложенности, внутренний класс всегда может напрямую обращаться ко всем членам всех классов, в которые он встроен.

Каждый внутренний класс способен независимо наследовать определенную реализацию. Таким образом, внутренний класс не ограничен при наследовании в ситуациях, где внешний класс уже наследует реализацию.
Внутренний класс выступает как "довесок" решения проблемы множественного наследования. Интерфейсы берут на себя часть этой задачи, тогда как внутренние классы фактически обеспечивают "множественное наследование реализации". Другими словами, внутренние классы позволяют наследовать от несколькоих не-интерфейсов.

- У внутреннего класса может существовать произвольное количество экземпляров, каждый из которых обладает собственной информацией состояния, не зависящей от состояния объекта внешнего класса.
- Один внешний класс может содержать несколько внутренних классов, по-разному реализующих один и тот же интерфейс или наследующих от единого базового класса.
- Место созадния объекта внутреннего класса не привязано к месту и времени создания объекта вншнего класса.
- Внутренний класс не использует тип отношений классов "является тем-то", способных вызвать недоразуменя; он представляет собой отдельную сущность.

Можно ли переопределить внутренний класс? Это было бы довольно интересно, но "переопределение" внутреннего класса, как если бы он был еще одним методом внешнего класса, фактически не имеет никакого эффекта. 

===================================
===================================

# КОМПОЗИЦИЯ
Композиция - механизм построения нового класса из объектов существующих классов. Просто используется функциональность готового кода, а не его структура. Композиция в основном применяется, когда в новом классе необходимо использовать функциональность уже существующего класса, но не его интерфейс. То есть вы встраиваете объект, чтобы использовать его возможности в новом классе, а пользователь класса видит определенный вами интерфейс, но не замечает встроенных объектов. Для этого внедряемые объекты объявляются со спецификатором private. 

===================================
===================================

# ОТЛИЧИЕ MAVEN ОТ ANT
ANT - гибкий инструмент скриптового типа. Имеет большое количество реализованных "команд", которые можно включать в любом количестве и любом порядке в т.н. задачи. Задачи тоже могут иметь зависимости, при этом ant сортирует весь граф зависимостей и выполняет задачи в гарантированно правильном порядке.
Те команды, которые требуют использования classpath, имеют теги, позволяющие этот classpath указать. Можно указывать директории с классами, jar-файлы, директории, содержащие jar-файлы.
При отсутствии нужной команды можно ее написать - API легко расширяем.

MAVEN - достаточно жесткий сборщик. Инструмент заточен под сборку программного продукта, написанного на Java. Имеет несколько жизненных циклов - default (сборочный), site и clean. Каждый жизненный цикл имеет предопределенные фазы, к которым можно привязывать выполнение плагинов.
classpath формируется автоматически. Сборочный скрипт содержит секцию зависимостей, в которой указываются все необходимые библиотеки с версиями. Библиотеки берутся из репозитория. В репозитории вместе с библиотеками хранятся их описатели, в которых указаны уже зависимости библиотек.
Таким образом, maven позволяет указать только те зависимости, которые нужны Вам в коде. При правильно указаном репозитории (или репозиториях) все библиотеки автоматически будут скачаны вместе со всеми зависимостями. Собственно, это одна из ключевых особенностей maven.
MAVEN хорош, когда Вам нужно сделать типовую задачу - собрать приложение, сгенерировать по нему документацию. Когда нужно что-то более сложное - мы писали ant-скрипт и вызывали его из maven-а.

===================================
===================================

Концепция нескольких объектов, "упакованных" в один объект, называется кортежем (tuple). Получатель объекта может читать элементы, но не может добавлять их (эта концепция еще называется объектом предеачи данных).
Если возможно параметризовать метод вместо целого класса, вероятно, стоит выбрать именно этот вариант. Кроме того, счатические методы не имеют доступа к параметрам типа парметризованных классов; если такие методы должны исползовать параметризацию, это должно проиходить на уровне метода, а не на уровне класса.
Класс и метод могу быть параметризованы вместе либо кто-то один из них.

===================================
===================================

Java SE — стандартная версия платформы Java 2, предназначенная для создания и исполнения апплетов и приложений, рассчитанных на индивидуальное пользование или на использование в масштабах малого предприятия. Не включает в себя многие возможности, предоставляемые более мощной и расширенной платформой Java 2 Enterprise Edition (J2EE), рассчитанной на создание коммерческих приложений масштаба крупных и средних предприятий.

Java EE - набор спецификаций и соответствующей документации для языка Java, описывающей архитектуру серверной платформы для задач средних и крупных предприятий.
JEE является промышленной технологией и в основном используется в высокопроизводительных проектах, в которых необходима надежность, масштабируемость, гибкость.
Популярности JEE также способствует то, что Sun предлагает бесплатный комплект разработки, SDK, позволяющий предприятиям разрабатывать свои системы, не тратя больших средств. В этот комплект входит сервер приложений GlassFish с лицензией для разработки.

Java EE включает в себя стандарты следующих технологий:
EJB - Enterprise JavaBeans — спецификация технологии серверных компонентов, содержащих бизнес-логику
JPA - Java Persistence API
Сервлет - Обслуживание запросов веб-клиентов
JSP - JavaServer Pages — динамическая генерация веб-страниц на стороне сервера
JSTL - JavaServer Pages Standard Tag Library
JSF - JavaServer Faces — компонентный серверный фреймворк для разработки веб-приложений на технологии Java
JAX-WS - Java API for XML Web Services — создание веб-сервисов
JAX-RS - Java API for RESTful Web Services — создание RESTful веб-сервисов
JNDI - Java Naming and Directory Interface — служба каталогов
JMS - Java Message Service — обмен сообщениями
JTA - Java Transaction API
JAAS - Java Authentication and Authorization Service — Java-реализация PAM
JavaMail - Получение и отправка электронной почты
JACC - Java Authorization Contract for Containers
JCA - J2EE Connector Architecture
JAF - JavaBeans Activation Framework
StAX - Streaming API for XML
CDI - Context and Dependency Injection

===================================
===================================



===================================
===================================

===================================
===================================

===================================
===================================

# Аксиомы программирования
	- Если есть возможность воспользоваться чужим опытом – изучи ее.
	- Если ты не понимаешь, что делаешь – делай это тщательно.
	- Программный код должен читаться легче, чем писаться.
	- Качественным является код, максимально приспособленный к поддержке.

В проектировании приложения есть числа 1 и 0. Что означает, что компонент приложения либо есть, либо его нет. В случае возможного присутствия хотя бы двух одинаковых компонентов, стоит считать, что их может быть неопределенное число N и, соответственно, основывать бизнес-логику именно на этом предположении.

Константа есть отражение нашего предположения о том, что некоторая величина имеет заранее определенное постоянное значение.

XP как методология предназначена для уменьшения затрат на разработку и поддержку ПО. При этом она обеспечивает гибкость процесса разработки, качество продукта и его соответствие реальным потребностям заказчика.
...каждая команда должна выбрать наиболее подходящий ей процесс и активно изменять его, подстраивая под нужды конкретного проекта.

В основе существования команды лежат четыре принципа – доверие, равенство, уважение и поддержка.
Лидер – это
а) полноправный член команды,
б) ведущий команду за собой,
в) принимающий решения, направленные на наиболее эффективное достижение цели команды.

В конечном итоге все эти возражения упираются в отсутствие (и даже неприятие!) командных ценностей – доверия, равенства, уважения, поддержки и ответственности. Все эти составляющие жизненно необходимы для успешной реализации практики коллективного владения кодом:

Доверие – я доверяю членам моей команды в том, что они не повесят на меня ответственность за свои ошибки
Равенство – я исправляю любой код, вне зависимости от авторства
Уважение – я уважаю членов команды, поэтому исправляю свои ошибки сам
Поддержка – я исправляю чужие ошибки: мне это несложно, а товарищу по команде – помощь
Ответственность – я отвечаю за свои действия и ошибки





# Даны 2 таблицы: Employee (id_employee, salary, department_id_fk); Department (id_department, department_name). Написать sql-запрос, который выберет названия отделов, суммарная зарплата сотрудников в которых больше 1000. 
	select department_name from Department as dep
	join Employee as emp on dep.id_department=emp.id_employee
	group by dep.department_name
	having sum(eml.salary)>1000