JavaScript изначально создавался для того, чтобы сделать web-странички «живыми». Программы на этом языке называются скриптами. В браузере они подключаются напрямую к HTML и, как только загружается страничка — тут же выполняются.

Планировалось, что JavaScript будет эдаким «младшим братом» Java. Однако, история распорядилась по-своему, JavaScript сильно вырос, и сейчас это совершенно независимый язык, со своей спецификацией, которая называется ECMAScript, и к Java не имеет никакого отношения.

JavaScript может выполняться не только в браузере, а где угодно, нужна лишь специальная программа — интерпретатор. Процесс выполнения скрипта называют «интерпретацией».

Современный JavaScript — это «безопасный» язык программирования общего назначения. Он не предоставляет низкоуровневых средств работы с памятью, процессором, так как изначально был ориентирован на браузеры, в которых это не требуется.

Что же касается остальных возможностей — они зависят от окружения, в котором запущен JavaScript. В браузере JavaScript умеет делать всё, что относится к манипуляции со страницей, взаимодействию с посетителем и, в какой-то мере, с сервером:
- Создавать новые HTML-теги, удалять существующие, менять стили элементов, прятать, показывать элементы и т.п.
- Реагировать на действия посетителя, обрабатывать клики мыши, перемещения курсора, нажатия на клавиатуру и т.п.
- Посылать запросы на сервер и загружать данные без перезагрузки страницы (эта технология называется "AJAX").
- Получать и устанавливать cookie, запрашивать данные, выводить сообщения…
- …и многое, многое другое!

Что не умеет JS:
- JavaScript не может читать/записывать произвольные файлы на жесткий диск, копировать их или вызывать программы. Он не имеет прямого доступа к операционной системе.
Современные браузеры могут работать с файлами, но эта возможность ограничена специально выделенной директорией — «песочницей». Возможности по доступу к устройствам также прорабатываются в современных стандартах и частично доступны в некоторых браузерах.
- JavaScript, работающий в одной вкладке, не может общаться с другими вкладками и окнами, за исключением случая, когда он сам открыл это окно или несколько вкладок из одного источника (одинаковый домен, порт, протокол).
Есть способы это обойти, и они раскрыты в учебнике, но они требуют специального кода на оба документа, которые находятся в разных вкладках или окнах. Без него, из соображений безопасности, залезть из одной вкладки в другую при помощи JavaScript нельзя.
- Из JavaScript можно легко посылать запросы на сервер, с которого пришла страница. Запрос на другой домен тоже возможен, но менее удобен, т. к. и здесь есть ограничения безопасности.

HTML 5 — эволюция стандарта HTML, добавляющая новые теги и, что более важно, ряд новых возможностей браузерам.
Вот несколько примеров:
- Чтение/запись файлов на диск (в специальной «песочнице», то есть не любые).
- Встроенная в браузер база данных, которая позволяет хранить данные на компьютере пользователя.
- Многозадачность с одновременным использованием нескольких ядер процессора.
- Проигрывание видео/аудио, без Flash.
- 2D и 3D-рисование с аппаратной поддержкой, как в современных играх.
- Многие возможности HTML5 всё ещё в разработке, но браузеры постепенно начинают их поддерживать.

Атрибут async
Поддерживается всеми браузерами, кроме IE9-. Скрипт выполняется полностью асинхронно. То есть, при обнаружении <script async src="..."> браузер не останавливает обработку страницы, а спокойно работает дальше. Когда скрипт будет загружен — он выполнится.
Атрибут defer
Поддерживается всеми браузерами, включая самые старые IE. Скрипт также выполняется асинхронно, не заставляет ждать страницу, но есть два отличия от async.
Первое — браузер гарантирует, что относительный порядок скриптов с defer будет сохранён.

То есть, в таком коде (с async) первым сработает тот скрипт, который раньше загрузится:

<script src="1.js" async></script>
<script src="2.js" async></script>
А в таком коде (с defer) первым сработает всегда 1.js, а скрипт 2.js, даже если загрузился раньше, будет его ждать.

<script src="1.js" defer></script>
<script src="2.js" defer></script>
Поэтому атрибут defer используют в тех случаях, когда второй скрипт 2.js зависит от первого 1.js, к примеру — использует что-то, описанное первым скриптом.

Второе отличие — скрипт с defer сработает, когда весь HTML-документ будет обработан браузером.

Например, если документ достаточно большой…

<script src="async.js" async></script>
<script src="defer.js" defer></script>

Много много много букв
…То скрипт async.js выполнится, как только загрузится — возможно, до того, как весь документ готов. А defer.js подождёт готовности всего документа.

Это бывает удобно, когда мы в скрипте хотим работать с документом, и должны быть уверены, что он полностью получен.

Атрибуты async/defer — только для внешних скриптов

Скрипты вставляются на страницу как текст в теге <script>, либо как внешний файл через <script src="путь"></script>
Специальные атрибуты async и defer используются для того, чтобы пока грузится внешний скрипт — браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.
Разница между async и defer: атрибут defer сохраняет относительную последовательность скриптов, а async — нет. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async — нет.

В JavaScript можно объявлять переменные для хранения данных. Это делается при помощи var.
Технически, можно просто записать значение и без объявления переменной, однако по ряду причин это не рекомендуется.
Вместе с объявлением можно сразу присвоить значение: var x = 10.
Переменные, которые названы БОЛЬШИМИ_БУКВАМИ, являются константами, то есть никогда не меняются. Как правило, они используются для удобства, чтобы было меньше ошибок.

При сравнении значений разных типов, используется числовое преобразование. Оно применяется к обоим значениям.
Например:
alert( '2' > 1 ); // true, сравнивается как 2 > 1
alert( '01' == 1 ); // true, сравнивается как 1 == 1
alert( false == 0 ); // true, false становится числом 0
alert( true == 1 ); // true, так как true становится числом 1.

Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==.

Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так.
Они ведут себя по-другому.
Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
При преобразовании в число null становится 0, а undefined становится NaN.

Сравним null с нулём:
alert( null > 0 ); // false
alert( null == 0 ); // false
Итак, мы получили, что null не больше и не равен нулю. А теперь…
alert(null >= 0); // true
Как такое возможно? Если нечто «больше или равно нулю», то резонно полагать, что оно либо больше, либо равно. Но здесь это не так.
Дело в том, что алгоритмы проверки равенства == и сравнения >= > < <= работают по-разному.
Сравнение честно приводит к числу, получается ноль. А при проверке равенства значения null и undefined обрабатываются особым образом: они равны друг другу, но не равны чему-то ещё.

Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью.

- В JavaScript есть логические значения true (истина) и false (ложь). Операторы сравнения возвращают их.
- Строки сравниваются побуквенно.
- Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства === (!==).
- Значения null и undefined равны == друг другу и не равны ничему другому. В других сравнениях (с участием >,<) их лучше не использовать, так как они ведут себя не как 0.

Окно сообщения, которое выводится, является модальным окном. Слово «модальное» означает, что посетитель не может взаимодействовать со страницей, нажимать другие кнопки и т.п., пока не разберётся с окном. В данном случае – пока не нажмёт на «OK».

- alert выводит сообщение.
- prompt выводит сообщение и ждёт, пока пользователь введёт текст, а затем возвращает введённое значение или null, если ввод отменён (CANCEL/Esc).
- confirm выводит сообщение и ждёт, пока пользователь нажмёт «OK» или «CANCEL» и возвращает true/false.

ЧИСЛЕННОЕ ПРЕОБРАЗОВАНИЕ:
Значение	Преобразуется в…
undefined	NaN
null	0
true / false	1 / 0
Строка	Пробельные символы по краям обрезаются. 
Далее, если остаётся пустая строка, то 0, иначе из непустой строки «считывается» число, при ошибке результат NaN.

СПЕЦИАЛЬНЫЕ ЗНАЧЕНИЯ:
Значение	Преобразуется в…
undefined	NaN
null	0

ЛОГИЧЕСКОЕ ПРЕОБРАЗОВАНИЕ:
Значение	Преобразуется в…
undefined, null		false
Числа				Все true, кроме 0, NaN — false.
Строки				Все true, кроме пустой строки "" — false
Объекты				Всегда true
Для явного преобразования используется двойное логическое отрицание !!value или вызов Boolean(value).

В JavaScript есть три преобразования:
Строковое: String(value) — в строковом контексте или при сложении со строкой. Работает очевидным образом.
Численное: Number(value) — в численном контексте, включая унарный плюс +value. Происходит при сравнении разных типов, кроме строгого равенства.
Логическое: Boolean(value) — в логическом контексте, можно также сделать двойным НЕ: !!value.

Условие в скобках интерпретируется как логическое значение, поэтому вместо while (i!=0) обычно пишут while (i):
var i = 3;
while (i) { // при i, равном 0, значение в скобках будет false и цикл остановится
  alert( i );
  i--;
}

JavaScript поддерживает три вида циклов:
- while — проверка условия перед каждым выполнением.
- do..while — проверка условия после каждого выполнения.
- for — проверка условия перед каждым выполнением, а также дополнительные настройки.
Чтобы организовать бесконечный цикл, используют конструкцию while(true). При этом он, как и любой другой цикл, может быть прерван директивой break.
Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует — используют директиву continue.
Обе этих директивы поддерживают «метки», которые ставятся перед циклом. Метки — единственный способ для break/continue повлиять на выполнение внешнего цикла.
Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.

Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных.
Переменные, объявленные на уровне всего скрипта, называют «глобальными переменными».

Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.

Функции в JavaScript являются значениями. Их можно присваивать, передавать, создавать в любом месте кода.
Если функция объявлена в основном потоке кода, то это Function Declaration.
Если функция создана как часть выражения, то это Function Expression.
Между этими двумя основными способами создания функций есть следующие различия:

Function Declaration	Function Expression
Время создания	До выполнения первой строчки кода.	Когда управление достигает строки с функцией.
Можно вызвать до объявления	Да (т.к. создаётся заранее)	Нет
Условное объявление в if	Не работает	Работает
Иногда в коде начинающих разработчиков можно увидеть много Function Expression. Почему-то, видимо, не очень понимая происходящее, функции решают создавать как var func = function(), но в большинстве случаев обычное объявление функции — лучше.
Если нет явной причины использовать Function Expression — предпочитайте Function Declaration.

Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
Рекурсия — это когда функция вызывает сама себя, как правило, с другими аргументами.
Существуют много областей применения рекурсивных вызовов. Здесь мы посмотрели на один из них — решение задачи путём сведения её к более простой (с меньшими аргументами), но также рекурсия используется для работы с «естественно рекурсивными» структурами данных, такими как HTML-документы, для «глубокого» копирования сложных объектов.


Есть 5 «примитивных» типов и объекты:
x = 1;             // число
x = "Тест";        // строка, кавычки могут быть одинарные или двойные
x = true;          // булево значение true/false
x = null;          // спец. значение (само себе тип)
x = undefined;     // спец. значение (само себе тип)

Значение null не является «ссылкой на нулевой адрес/объект» или чем-то подобным. Это просто специальное значение.
Значение undefined означает «переменная не присвоена».
Исключение: значения null и undefined ведут себя в сравнениях не как ноль.

Infinity — особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.
Бесконечность можно присвоить и в явном виде: var x = Infinity.

Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).
Значение NaN — единственное, в своем роде, которое не равно ничему, включая себя.
Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false — для любого другого значения.
Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN.
Никакие математические операции в JavaScript не могут привести к ошибке или «обрушить» программу.
В худшем случае, результат будет NaN.

Никакие математические операции в JavaScript не могут привести к ошибке или «обрушить» программу.
В худшем случае, результат будет NaN.
Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.

Для проверки строки на число можно использовать функцию isNaN(str).
Она преобразует строку в число аналогично +, а затем вернёт true, если это NaN, т.е. если преобразование не удалось:

var x = prompt("Введите значение", "-11.5");
if (isNaN(x)) {
  alert( "Строка преобразовалась в NaN. Не число" );
} else {
  alert( "Число" );
}
Однако, у такой проверки есть две особенности:
- Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами.
- Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает числами значения false, true, null, так как они хотя и не числа, но преобразуются к ним.

Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity — используйте следующую функцию isNumeric.

Одна из самых частых операций с числом — округление. В JavaScript существуют целых 3 функции для этого.
Math.floor - Округляет вниз
Math.ceil - Округляет вверх
Math.round - Округляет до ближайшего целого
alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3

Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей. Например, округлим 3.456 до 2го знака после запятой:
var n = 3.456;
alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46

- Числа могут быть записаны в шестнадцатиричной, восьмеричной системе, а также «научным» способом.
- В JavaScript существует числовое значение бесконечность Infinity.
- Ошибка вычислений дает NaN.
- Арифметические и математические функции преобразуют строку в точности в число, игнорируя начальные и конечные пробелы.
- Функции parseInt/parseFloat делают числа из строк, которые начинаются с числа.
- Есть четыре способа округления: Math.floor, Math.round, Math.ceil и битовый оператор. Для округления до нужного знака используйте +n.toFixed(p) или трюк с умножением и делением на 10p.
- Дробные числа дают ошибку вычислений. При необходимости ее можно отсечь округлением до нужного знака.
- Случайные числа от 0 до 1 генерируются с помощью Math.random(), остальные — преобразованием из них.

Случайное из интервала (0, max):
var max = 10;
alert( Math.random() * max );

Случайное из интервала (min, max):
var min = 5,
  max = 10;
alert( min + Math.random() * (max - min) );

Случайное целое от min до max:
function randomInteger(min, max) {
    var rand = min - 0.5 + Math.random() * (max - min + 1)
    rand = Math.round(rand);
    return rand;
  }
alert( randomInteger(5, 10) );

СТРОКИ
Обратите внимание, str.length — это свойство строки, а str.charAt(pos) — метод, т.е. функция.
Обращение к методу всегда идет со скобками, а к свойству — без скобок.

substring(start [, end])
Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end. Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки. Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end.

substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов.

slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров — такой же как в substring. Отрицательные значения отсчитываются от конца строки

Если выбирать из этих трёх методов один, для использования в большинстве ситуаций — то это будет slice: он и отрицательные аргументы поддерживает и работает наиболее очевидно.

Все строки имеют внутреннюю кодировку Юникод.
- Строчные буквы идут после заглавных, поэтому они всегда больше.
В частности, 'а'(код 1072) > 'Я'(код 1071).
- Ряд букв, например ё, находятся вне основного алфавита.

Кстати, если мы знаем код символа в кодировке юникод, то можем добавить его в HTML, используя «числовую ссылку» (numeric character reference).
Для этого нужно написать сначала &#, затем код, и завершить точкой с запятой ';'. Например, символ 'а' в виде числовой ссылки: &#1072;.
Если код хотят дать в 16-ричной системе счисления, то начинают с &#x.
В юникоде есть много забавных и полезных символов, например, символ ножниц: ✂ (&#x2702;), дроби: ½ (&#xBD;) ¾ (&#xBE;) и другие. Их можно использовать вместо картинок в дизайне.

Сравнение строк s1 и s2 обрабатывается по следующему алгоритму:

Сравниваются первые символы: s1[0] и s2[0]. Если они разные, то сравниваем их и, в зависимости от результата их сравнения, возвратить true или false. Если же они одинаковые, то…
Сравниваются вторые символы s1[1] и s2[1]
Затем третьи s1[2] и s2[2] и так далее, пока символы не будут наконец разными, и тогда какой символ больше — та строка и больше. Если же в какой-либо строке закончились символы, то считаем, что она меньше, а если закончились в обеих — они равны.

Числа в виде строк сравниваются как строки
Бывает, что числа приходят в скрипт в виде строк, например как результат prompt. В этом случае результат их сравнения будет неверным:
alert( "2" > "14" ); // true, так как это строки, и для первых символов верно "2" > "1"
Если хотя бы один аргумент — не строка, то другой будет преобразован к числу:
alert( 2 > "14" ); // false

- Строки в JavaScript имеют внутреннюю кодировку Юникод. При написании строки можно использовать специальные символы, например \n и вставлять юникодные символы по коду.
- Мы познакомились со свойством length и методами charAt, toLowerCase/toUpperCase, substring/substr/slice (предпочтителен slice). Есть и другие методы, например trim обрезает пробелы с начала и конца строки.
- Строки сравниваются побуквенно. Поэтому если число получено в виде строки, то такие числа могут сравниваться некорректно, нужно преобразовать его к типу number.
- При сравнении строк следует иметь в виду, что буквы сравниваются по их кодам. Поэтому большая буква меньше маленькой, а буква ё вообще вне основного алфавита.
- Для правильного сравнения существует целый стандарт ECMA 402. Это не такое простое дело, много языков и много правил. Он поддерживается во всех современных браузерах, кроме IE10-, в которых нужна библиотека https://github.com/andyearnshaw/Intl.js/. Такое сравнение работает через вызов str1.localeCompare(str2).

Кстати, в кодироке Unicode существует специальный символ «троеточие»: … (HTML: &hellip;), который можно использовать вместо трёх точек. Если его использовать, то можно отрезать только один символ.



# Объекты
Объекты в JavaScript сочетают в себе два важных функционала.
- Первый — это ассоциативный массив: структура, пригодная для хранения любых данных. В этой главе мы рассмотрим использование объектов именно как массивов.
- Второй — языковые возможности для объектно-ориентированного программирования. Эти возможности мы изучим в последующих разделах учебника.

Ассоциативный массив — структура данных, в которой можно хранить любые данные в формате ключ-значение.
Её можно легко представить как шкаф с подписанными ящиками. Все данные хранятся в ящичках. По имени можно легко найти ящик и взять то значение, которое в нём лежит.

Пустой объект («пустой шкаф») может быть создан одним из двух синтаксисов:
1. o = new Object();
2. o = {}; // пустые фигурные скобки
Обычно все пользуются синтаксисом (2), т.к. он короче.

Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства (иногда говорят «по ключу»).
Основные операции с объектами — это создание, получение и удаление свойств.
Для обращения к свойствам используется запись «через точку», вида объект.свойство, например:
// при присвоении свойства в объекте автоматически создаётся "ящик"
// с именем "name" и в него записывается содержимое 'Вася'
person.name = 'Вася';
person.age = 25; // запишем ещё одно свойство: с именем 'age' и значением 25
Значения хранятся «внутри» ящиков. Обратим внимание — любые значения, любых типов: число, строка — не важно.
Чтобы прочитать их — также обратимся через точку.
Удаление осуществляется оператором delete:
delete person.age;
Для проверки существования свойства в объекте есть оператор in.
Его синтаксис: "prop" in obj, причем имя свойства — в виде строки, например:
if ("name" in person) {
  alert( "Свойство name существует!" );
}
Впрочем, чаще используется другой способ — сравнение значения с undefined.
Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет. Ошибки не будет.
Но если свойство не существует, то вернется специальное значение undefined:
var person = {};
alert( person.lalala ); // undefined, нет свойства с ключом lalala

Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']:
var person = {};
person['name'] = 'Вася'; // то же что и person.name = 'Вася'

Объекты — это ассоциативные массивы с дополнительными возможностями:
- Доступ к элементам осуществляется:
- - Напрямую по ключу obj.prop = 5
- - Через переменную, в которой хранится ключ:
      var key = "prop";
      obj[key] = 5
- Удаление ключей: delete obj.name.
- Существование свойства может проверять оператор in: if ("prop" in obj), как правило, работает и просто сравнение if (obj.prop !== undefined).


# ОЪЕКТЫ: ПЕРЕБОР СВОЙСТВ

for (key in obj) {
  /* ... делать что-то с obj[key] ... */
}
При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.

Пример итерации по свойствам:
var menu = {
  width: 300,
  height: 200,
  title: "Menu"
};
for (var key in menu) {
  // этот код будет вызван для каждого свойства объекта
  // ..и выведет имя свойства и его значение

  alert( "Ключ: " + key + " значение:" + menu[key] );
}

- Цикл по ключам: for (key in obj).
- Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые — сортируются (в современных браузерах).
- Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +, как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.



# ОБЪЕКТЫ: ПЕРЕДАЧА ПО ССЫЛКЕ

Обычные значения: строки, числа, булевы значения, null/undefined при присваивании переменных копируются целиком или, как говорят, «по значению».
	var message = "Привет";
	var phrase = message;
В результате такого копирования получились две полностью независимые переменные, в каждой из которых хранится значение "Привет".

!! При копировании переменной с объектом — копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Так как объект всего один, то изменения через любую переменную видны в других переменных. 


Иногда, на практике — очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.
Что ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов. Если же свойства объектов, в свою очередь, могут хранить ссылки на другие объекты, то нужно обойти такие подобъекты и тоже склонировать их. Это называют «глубоким» клонированием.

- Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.
- Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.
Это — одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью.



# МАССИВЫ С ЧИСЛОВЫМИ ИНДЕКСАМИ
Массив — разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.
Пустой массив:
	var arr = [];
Массив fruits с тремя элементами:
	var fruits = ["Яблоко", "Апельсин", "Слива"];
- Через alert можно вывести и массив целиком.
- В массиве может храниться любое число элементов любого типа.
- Ещё одно следствие — можно присваивать в массив любые свойства.
- Длина length — не количество элементов массива, а последний индекс + 1.
- При уменьшении length массив укорачивается.

pop - Удаляет последний элемент из массива и возвращает его
push - Добавляет элемент в конец массива
shift - Удаляет из массива первый элемент и возвращает его
unshift - Добавляет элемент в начало массива



# МАССИВЫ: МЕТОДЫ
Методы:
- push/pop, shift/unshift, splice — для добавления и удаления элементов.
- join/split — для преобразования строки в массив и обратно.
- slice — копирует участок массива.
- sort — для сортировки массива. Если не передать функцию сравнения — сортирует элементы как строки.
- reverse — меняет порядок элементов на обратный.
- concat — объединяет массивы.
- indexOf/lastIndexOf — возвращают позицию элемента в массиве (не поддерживается в IE8-).









