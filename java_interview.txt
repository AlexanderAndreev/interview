===================================
=  EXCEPTIONS                     =
===================================

# EXCEPTIONS
— Throwable и Exception и все их наследники (за исключением наследников Error-а и RuntimeException-а) — checked
— Error и RuntimeException и все их наследники — unchecked

                    Object
                      |
                  Throwable
                  /      \
              Error     Exception
                            |
                    RuntimeException

Необходимо понимать, что 
— проверка на cheched исключения происходит в момент компиляции (compile-time checking)
— перехват исключений (catch) происходит в момент выполнения (runtime checking)

Все классы обрабатывающие ошибки являются наследниками класса java.lang.Throwable. Только объекты этого класса или его наследников могут быть "брошены" JVM при возникновении какой-нибудь исключительной ситуации, а также только эти объекты могут быть "брошены" во время выполнения программы с помощью ключевого слова throw.
Прямыми наследниками класса Throwable являются Error и Exception.

Error - это подкласс, который показывает серьезные проблемы возникающие во время выполнения приложения. Большинство из этих ошибок сигнализируют о ненормальном ходе выполнения программы, т.е. о каких-то критических проблемах. Эти ошибки не рекомендуется отмечать в методах посредством throws-объявления, поэтому они также очень часто называются непроверяемые (unchecked). Примерами таких исключений являются: ThreadDeath, VirtualMachineError, OutOfMemoryError.

Exception - это подкласс исключений, которые приложение может "выбрасывать" во время своей работы и которые должны быть обработаны в тех методах, где они возникают, или "проброшены" дальше, для обработки на более позднем этапе. Это обычно проверяемые (checked) исключения. Примерами являются: ClassNotFoundException, IOException.

У класса Exception есть один подкласс, который не рекомендуется декларировать в методах с помощью throws. Это RuntimeException и все его наследники. Исключения этого типа возникают во время выполнения программы. Поскольку они могут возникнуть в любом методе, то пришлось бы декларировать их везде, что существенно усложнило бы жизнь разработчикам. Вместо этого рекомендуется в коде программы делать необходимые проверки, чтоб избежать возникновения этих исключений. IndexOutOfBoundsException, IllegalArgumentException, NullPointerException.

Cвойством транзакционности исключения не обладают – действия, произведенные в блоке try до возникновения исключения, не отменяются поcле его возникновения.



===================================
=  STRING                         =
===================================
new String("") vs ""
	Когда используется new(), строка сразу добавляется в heap и НЕ добавляется в string pool.
	String pool -- пул, в котором хранятся все определённые строки. и если создаётся новая, компилятор проверяет, есть ли её значение в пуле, если есть, то вновь созданной присваивается ссылка на уже существующую, таким образом экономится память. Это безопасно, что разные String-и могут ссылаться на один объект, потому что String -- immutable. Чтобы добавить строку в пул, используется метод String.intern();
	Строки созданные, как String s = "s"; добавляются в пул автоматически.
	При использование выражения:
	String s1 = ""; - в пуле создаётся запись "",
	при повторном вызове:
	String s2=""; - ссылка s2 уже ссылается га существующую запись в пуле "",
	в результате : s1==s2 ( так как ссылаются на одну запись в пуле ) и s1.equals(s2);
	При вызове String s3=new String(""); в куче создается новый объект, который ссылается на заново созданное место в пуле и уже s1==s3 выдаст false.

# Почему String в Java является immutable (неизменным после создания)?
- Безопасность.
String широко используется , как параметр для многих классов Java, в частности для открытия сетевых соединений, подключений к БД, открытию файлов и пр. И если бы строка изменялась, то мы могли получить доступ к объекту (файлу например), на который мы имеем право, затем изменить строку с именем (случайно или намеренно) и получить доступ уже к другому файлу.
Так же String используется в механизме загрузки файлов, и это -- фундаментальный аспект. И если бы строка изменялась, то запрос на загрузку "java.io.Writer" мог бы быть изменён на 
"DiskErasingWriter".
- Hashcode
Из-за того, что строка не изменяется, она кэширует свой хэшкод и не вычисляет его каждый раз, когда мы его вызываем, что делает строку очень быстрой как ключ для hashmap.
- Многопоточность
immutable делает экземпляры строк thread-safe.

Я часто вижу конструкции типа str.equals("abc"). И тут есть небольшие грабли – перед этим сравнением правильно бы было сравнить str с null, чтобы не получить NullPointerException. Т.е. правильной будет конструкция str != null && str.equals("abc"). Между тем – ее можно упростить. Достаточно написать всего лишь "abc".equals(str). Проверка на null в этом случае не нужна.
 
String str = "abcdefghijklmnopqrstuvwxyz";
str = new String(str.substring(5,10));



===================================
=  COLLECTIONS                    =
===================================

= ARRAYLIST =
Только что созданный объект list, содержит свойства elementData и size. Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов типа Object (с приведением к типу, разумеется).

Добавление в конец списка. Внутри метода add(value) происходят следующие вещи:
1) проверяется, достаточно ли места в массиве для вставки нового элемента;
	ensureCapacity(size + 1);
2) добавляется элемент в конец (согласно значению size) массива.
	elementData[size++] = element;

Добавление в «середину» списка (list.add(5, "100");)
1) проверяется, достаточно ли места в массиве для вставки нового элемента;
	ensureCapacity(size + 1);
2) подготавливается место для нового элемента с помощью System.arraycopy();
	System.arraycopy(elementData, index, elementData, index + 1, size - index);
3) перезаписывается значение у элемента с указанным индексом.
	elementData[index] = element;
	size++;

Удалять элементы можно двумя способами:
— по индексу remove(index)
— по значению remove(value)

С удалением элемента по индексу всё достаточно просто
	list.remove(5);
Сначала определяется какое количество элементов надо скопировать
	int numMoved = size - index - 1;
затем копируем элементы используя System.arraycopy()
	System.arraycopy(elementData, index + 1, elementData, index, numMoved);
уменьшаем размер массива и забываем про последний элемент
	elementData[--size] = null; // Let gc do its work


= LINKEDLIST =
Только что созданный объект list, содержит свойства header и size.
header — псевдо-элемент списка. Его значение всегда равно null, a свойства next и prev всегда указывают на первый и последний элемент списка соответственно. Так как на данный момент список еще пуст, свойства next и prev указывают сами на себя (т.е. на элемент header). Размер списка size равен 0.
	header.next = header.prev = header;

Добавление элемента в конец списка с помощью методом add(value), addLast(value) и добавление в начало списка с помощью addFirst(value) выполняется за время O(1).
Каждый раз при добавлении нового элемента, по сути выполняется два шага:
1) создается новый новый экземпляр класса Entry
	Entry newEntry = new Entry("0", header, header.prev);
2) переопределяются указатели на предыдущий и следующий элемент
	newEntry.prev.next = newEntry;
	newEntry.next.prev = newEntry;
	size++;



===================================
===================================

# HASHCODE/EQUALS
Реализация по умолчанию для hashCode() использует System.identityHashcode() метод для получения хэш кода. Этот метод возвращает хэш связанный с адресом памяти, где расположен объект. Конечный эффект использования стандартного выполнения equals() и hashCode() – это, то, что два объекта равны только тогда, когда они являются одним и тем же Java объектом. Для некоторых приложений это нормально, но не для нашего, чаще всего, это является проблемой.

Пользовательские equals() и hashCode() методы необходимы, потому что объекты такие как PixUser могут быть сохранены и извлечены из базы данных. Если вы сравните экземпляр PixUser, созданного при помощи своего конструктора с другим экземпляром, извлеченным из базы данных, то вы захотите чтобы они были равны, если все их значения имеют равные значения. PixUser считается равным нашим приложением если его или ее имя, email, фамилия, имя пользователя и пароль равны. Вам не нужно чтобы они были одинаковыми Java объектами.

HashCode
Хеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект. 
Этот метод реализован таким образом, что для одного и того-же входного объекта, хеш-код всегда будет одинаковым. Следует понимать, что множество возможных хеш-кодов ограничено примитивным типом int, а множество объектов ограничено только нашей фантазией. Отсюда следует утверждение: “Множество объектов мощнее множества хеш-кодов”. Из-за этого ограничения, вполне возможна ситуация, что хеш-коды разных объектов могут совпасть. 
Здесь главное понять, что:
•	Если хеш-коды разные, то и входные объекты гарантированно разные.
•	Если хеш-коды равны, то входные объекты не всегда равны.
Ситуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.
Создавая пользовательский класс, нужно переопределять методы hashCode() и equals(), что бы они корректно работали и учитывали данные объекта. Кроме того, если оставить реализацию из Object, то при использовании java.util.HashMap возникнут проблемы, поскольку HashMap активно используют hashCode() и equals() в своей работе

- для одного и того-же объекта, хеш-код всегда будет одинаковым;
- если объекты одинаковые, то и хеш-коды одинаковые (но не наоборот, см. правило 3)
- если хеш-коды равны, то входные объекты не всегда равны (коллизия); 
- если хеш-коды разные, то и объекты гарантированно разные;

При вычислении хэш-кода для объектов класса Object по умолчанию используется Park-Miller RNG алгоритм. В основу работы данного алгоритма положен генератор случайных чисел. Это означает, что при каждом запуске программы у объекта будет разный хэш-код.

Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)
Рефлексивность: Для всех ненулевых ссылок, a.equals(a)
Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c)
Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode()

===================================
===================================

IMMUTABLE CLASS
1. Не использовать set-методы
2. Все поля private final
3. Сделать класс final. Лучшим подходом будет создать private конструктор и создавать сущности factory-методом.

===================================
===================================

ООП:
- Инкапсуляция (encapsulation) — свойство языка прог. при котором сложные участки кода спрятаны от глаз программиста, и он не должен думать от реалицазии внутри методов. Достигается с помощью public, private  итд.
- Наследование (inheritance) — один из четырёх важнейших механизмов. Позволяет включать свойства и логику родительского класса.
- Полиморфизм (polymorphism) — возможность объектов с одинаковой спецификацией иметь различную реализацию. Имеем интерфейс (абстрактный), и классы реализующие его, каждый класс имеет свою логику.
- Абстракция — это выделение общих характеристик объекта,исключая набор незначительных. С помощью принципа абстракции данных,данные преобразуются в объекты. 
	Данные обрабатываются в виде цепочки сообщений между отдельными объектами. Все объекты проявляют свои уникальные признаки поведения.
	Огромный плюс абстракции в том, что она отделяет реализацию объектов от их деталей, что в свою очередь позволяет управлять функциями высокого уровня через функции низкого уровня

Объект – совокупность данных и методов работы с ними.
Класс – это описатель общих свойств группы объектов. Этими свойствами могут быть как характеристики объектов (размер, вес, цвет и т.п.), так и поведения, роли и т.п.

===================================
===================================

CLASSLOADER 
При реализации пользовательских загрузчиков важно помнить следующее:
- любой загрузчик должен явно или неявно расширять класс java.lang.ClassLoader;
- любой загрузчик должен поддерживать модель делегирования загрузки, образуя иерархию;
- в классе java.lang.ClassLoader уже реализован метод непосредственной загрузки — defineClass(...), который байт-код преобразует в java.lang.Class, осуществляя его валидацию;
- механизм рекурентного поиска также реализован в классе java.lang.ClassLoader и заботиться об это не нужно;
- для корректной реализации загрузчика достаточно лишь переопределить метод findClass() класса java.lang.ClassLoader.
иерархия класс лодеров:
Bootstrap
	  |
   System
	  |
   Common
   /     \
Webapp1   Webapp2 ... 
в жбосе каждое приложение ear, war и тд имеет свой класслодер.

===================================
===================================

FORWARD/REDIRECT
    Forward осуществляется переход на новую страницу, но запрос не меняется (на сервере). Передает на сервере запрос на другой url.
    Redirect создаётся новый запрос, все параметры, хранившиеся в старом удаляются.  Также редирект ‘убивает‘ переменные сессии (через клиента). Меняет адрес странички. То есть при редиректе 1 запроса сервер возвращает ответ клиенту у которого меняется урл в браузере и браузер опять отсылает запрос.

===================================
===================================

TRANSIENT
Оно применяется к полям класса и означает, что данное поле не входит в персистентное состояние класса.
Т.е. при сериализации данное поле не будет записываться. И, соответственно, при де-сериализации оно не будет восстанавливаться из потока байтов. 

===================================
===================================

 - java.lang - все обьекты обертки, Void, рефлексия, Class, Enum, Exception (Illegal и тд), Thread и тд
 - java.util - коллекции, пакет concurent, рандом, таймер, некоторые эксепшены, TimeZone, UUID
 - java.io. - File
 
===================================
===================================

Атомарность означает выполнение операции целиком непрерывно (либо невыполнение ее вовсе).
	В Java атомарными являются операции чтения/записи всех примитивных типов данных за исключением типов long и double, поскольку эти типы данных занимают два машинных слова, их операции чтения/записи являются составными операциями из двух атомарных операций над старшими и младшими битами числа соответственно.
	Однако операции над volatile long и volatile double атомарны.
	Операции над ссылками на объекты в Java являются всегда атомарными независимо от разрядности JVM и гарантируются JMM.
 
===================================
===================================

Размер Java объектов (http://habrahabr.ru/post/134102/) - JVM хранит для каждого объекта:
    Заголовок объекта - Заголовок: 8 байт;
    Память для примитивных типов;
    Память для ссылочных типов;
    Смещение/выравнивание — по сути, это несколько неиспользуемых байт, что размещаются после данных самого объекта. Это сделано для того, чтобы адрес в памяти всегда был кратным 
машинному слову, для ускорения чтения из памяти + уменьшения количества бит для указателя на объект + предположительно для уменьшения фрагментации памяти. Стоит также отметить, что в java 
размер любого объекта кратен 8 байтам! + после всего подсчета происходит выравнивание до кратности к 8 байтам.
 
===================================
===================================

Inversion of Control (инверсия управления) — это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода.
Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других 
компонентов.
Dependency Injection (внедрение зависимостей) — это одна из реализаций этого принципа (помимо этого есть еще Factory Method, Service Locator).
 
===================================
===================================

Spring. BeanFactory - это базовый интерфейс. Самые начальные его реализации передают например путь к xml (или даже properties) конфигурации и дальше можно доставтаь бины.
Продвинутая реализация ApplicationContext - она с поддержкой транзакций, AOP, обрабботка событий и тд. 
http://j4sq.blogspot.com/2012/01/java-spring-hibernate.html
 
===================================
===================================

REST - это архитектурный стиль, стандарт для создания веб сервисов. REST - метод взаимодействия компонентов распределённого приложения в сети Интернет, при котором вызов удаленной процедуры представляет собой обычный HTTP-запрос (обычно GET или POST; такой запрос называют REST-запрос), а необходимые данные передаются в качестве параметров запроса.
RESTFull - набор АПИ, которые следуют стилю REST
 
===================================
===================================

Maven - mvn archetype:create -DgroupId=com.mycompany.app -DartifactId=my-webapp  -DarchetypeArtifactId=maven-archetype-webapp - создает структуру проекта по архетипу.
            mvn install:install-file -Dfile=<path-to-file> -DgroupId=<group-id> -DartifactId=<artifact-id> -Dversion=<version> -Dpackaging=<packaging>  - инсталим артифакт в репозиторий.
	Nexus - через него можно настроить собственный репозиторий.
	maven-jar-plugin - плагин собирает в jar.
	maven-dependency-plugin - копирует зависимости в указанную директорию.
	jetty-maven-plugin - подключает к проекту джетти - то есть запускает сервер из джавы.
	maven-ejb-plugin - собирает ejb проект.
	maven-ear-plugin - собирает ear проект.
	maven-compiler-plugin - компилирует проект.
 
===================================
===================================

SQL, запросы, join  и тд.
	inner join - INNER JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах.
	left outer join - JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах + строки которые присутствуют только в левой колонке.
	right outer join -  JOIN позволяет извлекать строки, которые обязательно присутсвуют во всех объединяемых таблицах + строки которые присутствуют только в правой колонке.
	
	INSERT INTO table1 (username) VALUES ('foo'); 
	UPDATE table2 SET user_id='2', phone_number='200' WHERE phone_id='1';
	DELETE FROM table1 WHERE user_id = 1; 
	RENAME TABLE table1 TO nya;
	ALTER TABLE lcssm.application ADD CONSTRAINT uk_application_application_number UNIQUE (application_number);
	ALTER TABLE lcssm.application DROP CONSTRAINT uk_application_application_number;
	ALTER TABLE lcssm.application ADD CONSTRAINT chk_application_additional_info CHECK (additional_info <> '');
	ALTER TABLE lcssm.documents ALTER date DROP NOT NULL;
	ALTER TABLE lcssm.documents ALTER date SET NOT NULL;
	alter table lcssm.houses add column change_date bigint NOT NULL;
	alter table lcssm.houses drop column change_date;
	update lcssm.licenses set original_license_guid = null where version_number = 1;	
	group by групирует по строке, а having используется только вместе с group by и слежит для фильтрации по колонкам в group by.
 
===================================
===================================

Приниципы ACID:
Atomicity — Атомарность - Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние — со стороны будет казаться, что транзакции и не было. (Естественно, счётчики, индексы и другие внутренние структуры могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.)
	
Consistency — Согласованность - Транзакция достигающая своего нормального завершения (EOT – end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвертого свойства.Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисление, то система останется в некорректном состоянии и свойство согласованности будет нарушено.Наконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего,двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции, никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.
	 
Isolation — Изолированность - Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат. Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности Repeatable Read и ниже).

	Durability — Надежность - Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой 
транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может 
быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.
 
===================================
===================================

ArrayList - когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных мест, то вызов System.arraycopy() случится дважды: первый в ensureCapacity(), второй в самом методе add(index, value),
 что явно скажется на скорости всей операции добавления.
	В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину»,
	стоит использовать метод addAll(index, Collection). И хотя, данный метод скорее всего вызовет System.arraycopy() три раза,
	в итоге это будет гораздо быстрее поэлементного добавления.
	— Быстрый доступ к элементам по индексу за время O(1);
	 — Доступ к элементам по значению за линейное время O(n);
	 — Медленный, когда вставляются и удаляются элементы из «середины» списка;
	 — Позволяет хранить любые значения в том числе и null;
	 — Не синхронизирован.
	http://habrahabr.ru/post/128269/
	
LinkedList - связанный список, хранит элементы каждый из каторых имеет ссылку на предыдущий и следующий элемент.
 Поддерживает двунапрвленный итератор.
	— Из LinkedList можно организовать стэк, очередь, или двойную очередь, со временем доступа O(1);
	 — На вставку и удаление из середины списка, получение элемента по индексу или значению потребуется линейное время O(n).
	 Однако, на добавление и удаление из середины списка, используя ListIterator.add() и ListIterator.remove(), потребуется O(1);
	 — Позволяет добавлять любые значения в том числе и null. Для хранения примитивных типов использует соответствующие классы-оберки;
	 — Не синхронизирован.
	 
HashMap - — Добавление элемента выполняется за время O(1), потому как новые элементы вставляются в начало цепочки;
		 — Операции получения и удаления элемента могут выполняться за время O(1), если хэш-функция равномерно распределяет элементы 
		 и отсутствуют коллизии. Среднее же время работы будет ?(1 + ?), где ? — коэффициент загрузки. В самом худшем случае, 
		 время выполнения может составить ?(n) (все элементы в одной цепочке);
		 — Ключи и значения могут быть любых типов, в том числе и null. Для хранения примитивных типов используются соответствующие классы-оберки;
		 — Не синхронизирован.
		 В каждой цепочке хранятся значения, которые имеют ссылку на next элемент.

LinkedHashMap - Данная структура может слегка уступать по производительности родительскому HashMap, при этом время выполнения операций add(),
 contains(), remove() остается константой — O(1). Понадобится чуть больше места в памяти для хранения элементов и их связей, 
 но это совсем небольшая плата за дополнительные фишечки.
	 Вообще, из-за того что всю основную работу на себя берет родительский класс, серьезных отличий в реализации HashMap и 
	 LinkedHashMap не много. Можно упомянуть о парочке мелких:
	Методы transfer() и containsValue() устроены чуть проще из-за наличия двунаправленной связи между элементами;
	В классе LinkedHashMap.Entry реализованы методы recordRemoval() и recordAccess() 
	(тот самый, который помещает элемент в конец при accessOrder = true). В HashMap оба этих метода пустые.
	В каждой цепочке хранятся значения, кторые имеют ссылку на next элемент и на prev элемент.
	
	
TreeMap  - содержит упорядоченные данные отсортированные по компоратору. Почти во всех операциях участвует компаратор,
 а поиск например вернет запись если при сравнении компаратор выведет compareTo(p.key); == 0, 
При добавлении сравнивает с рутовым элементов (рут - первая запись в мапе),
и дальше в зависимости больше или равно сравнивается с left или right записями:
do {
                parent = t;
                cmp = cpr.compare(key, t.key);
                if (cmp < 0)
                    t = t.left;
                else if (cmp > 0)
                    t = t.right;
                else
                    return t.setValue(value);
            } while (t != null);
	
HashSet - внутри использует HashMap. Плюсы в постоянном доступе таких методов как add contain remove size.
TreSet - внутри использует TreeMap.
 
List, Set, Queue, Deque, Map(не наследуется от Collection). 
Set от List отличается тем, что в Set могут содержаться только уникальные объекты.  
Queue и Deque характеризуются тем, что элементы извлекаются в том же порядке, в котором ложатся (FIFO).
ArrayList обеспечивает наилучшее быстродействие, когда требуется часто извлекать произвольные объекты.
LinkedList - когда требуется много добавлять и удалять произвольные объекты.
HashTable, в отличие от HashMap, потокобезопасный, но более медленный. Однако, применять HashTable не стоит никогда, так как для многопоточности существует более новый и совершенный  ConcurrentHashTable.  Кроме неё, в пакете concurrent есть полезная коллекция ArrayBlockingQueue, которая представляет собой  упорядоченную блокирующую очередь, ей удобно применять для пулов соединений с БД


===================================
===================================

EJB - @StartUp - бин создается сразу после деплоя приложения. @Singleton -  бин будет существовать только в 1 экземпляре.
	Enterprise beans поддерживают два типа управления транцакциями: container-managed или bean-managed. По умолчанию, если явно не задано,
	то используется первый, с которым я сегодня разбирался и хочу рассказать.
	 По сути, это просто заметки, сделанные с документации Java EE 6 Tutorial.
	 Container-managed транзакции упрощают разработку, т.к. за границами транзакции следит контейнер EJB.
	 Транзакции, управляемые контейнером, могут работать как с session, так и с message-driven бинами.
	 Транзакция автоматически стартует перед началом запуска метода в бине и заканчивается по завершении этого метода.
	 Container-managed транзакции не поддерживают вложенные и мульти-транзакции.
	 Container-managed транзакция не должна использовать методы управления транзакциями, т. к. эти операции возложены на контейнер EJB.
	 Существует возможность управления запуском транзакций для ejb-методов. Если внутри транцакции вызывается метод другого бина,
	 то как должна вести себя транзакция с этим методом? На этот метод можно поставить различные ограничители принадлежности к текущей транзакции,
	 при помощи аннотации @TransactionAttribute:
	 Ограничения транзакции:
	REQUIRED - если метод запущен внутри транзакции, то он является частью транзакции. Если запущен вне транзакции, то в нем стартует новая транзакция.
    REQUIRES_NEW - если метод запускается внутри транзакции, то она останавливается, запускается новая, отрабатывается, а затем продолжает работу первая.
		Если метод запускается самостоятельно, то просто стартует новая транзакция. Данный модификатор служит для того, что бы быть уверенным, что всегда будет запущена новая транзакция.
    MANDATORY - если метод запущен внутри транзакции, то он является её частью. Если же запускается вне транзакции, то бросается исключение TransactionRequiredException.
    NOT_SUPPORTED - если метод запускается внутри транзакции, то на время работы метода транзакция останавливается, пока не отработается метод, травзакция в которм не стартуетс,
		затем транзакция продолжает работу. Если метод запускается вне транзакции, то транзакция в нем не стартует. Этот атрибут увеличивает производительность, т.к. транзакции связаны с дополнительными нагрузками.
    SUPPORTS - если внутри транзакции, то является частью транзакции, если запускается самостоятельно, то транзакция не стартует.
    NEVER - Если внутри транзакции, то бросается исключение RemoteException, если вне транзакции, то метод запускается без старта транзакции.

	http://sh2533.blogspot.com/2011/07/ejb.html

 
===================================
===================================

# java.util.concurrent.*
ArrayBlockingQueue, ConcurrentHashMap, AtomicInteger, Collections.synchronizedList(new LinkedList()) и другие интересности.
Concurrent Collections — набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета.
Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков.
Synchronizers — вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.
Executors — содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.
Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.
Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.
 
===================================
===================================

# Когда поток переходит из нового состояния в работоспособное?
Когда вызывается метод start(), поток переходит из нового состояния в работоспособное.
 Как заставить главный поток ждать завершения побочного?
Чтобы главный поток подождал завершения побочного потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.
Поток – часть процесса, состоящий из набора команд и имеющий одно адресное пространство. 
Поток создаётся наследованием класса Thread или реализацией интерфейса Runnable.
Запускается поток методом start(), который запускает метод  run(). Если поток был приостановлен, то запустить снова его можно методами notify() и notifyAll(), который запускает все приостановленные потоки. 
Остановить поток можно методом interrupt(). Приостановить его можно методом wait().
Состояния потока: новый, работоспособный, работающий, ожидающий, заблокированный, спящий, мёртвый. 

Поток создаётся либо наследованием от Thread, либо реализацией Runnable.

В Java существуют (существовали) средства для принудительного завершения потока. В частности метод Thread.stop() завершает поток незамедлительно после своего выполнения. Однако этот метод, а также Thread.suspend(), приостанавливающий поток, и Thread.resume(), продолжающий выполнение потока, были объявлены устаревшими и их использование отныне крайне нежелательно. Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии, что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке.
 
===================================
===================================

# Когда использовать абстрактный класс, а когда интерфейс?
При необходимости множественного наследования или добавить какую-нибудь функциональность классу, то лучше использовать интерфейс. Если класс имеет много методов и полей, которые повторяются для нескольких классов - то лучше абстрактный класс. Абстрактный класс имеет конструктор. В абстрактном классе могут быть неабстрактные методы. В абстрактном классе может быть конструктор, но создать экземпляр такого класса нельзя.
Интерфейсы и абстрактные классы могут содержать абстрактные методы, причём интерфейсы – только абстрактные методы. К тому же, интерфейсы могут содержать только константы. Нельзя создать объект абстрактного класса или интерфейса.

===================================
===================================

# Метод finalize().
Чтобы добавить в класс средство выполнения финализации, достаточно определить метод finalize(). Среда времени выполнения Java вызывает этот метод непосредственно перед удалением объекта данного класса. Внутри метода finalize() нужно указать те действия, которые должны быть выполнены перед уничтожением объекта. Сборщик мусора запускается периодически, проверяя наличие объектов, на которые отсутствуют ссылки как со стороны какого-либо текущего состояния, так и косвенные ссылки через другие ссылочные объекты. Непосредственно перед освобождением ресурсов среда времени выполнения Java вызывает метод finalize() по отношению к объекту.
 
===================================
===================================

# Ключевые слова final и static.
Final класс не может иметь наследников. Final метод не может быть переопределен в дочернем классе, final переменная это переменная, значение которой присваивается лишь однажды и потом не может быть изменено.
Static – так же используется в различных контекстах. Переменная, объявленная static, называется переменной класса и все экземпляры класса используют одну и ту же копию этой переменной. Более того, такая переменная может быть использована вообще без создания экземпляров класса. Статический метод так же может быть вызван без создания экземпляра класса.
 
===================================
===================================

# Как определить аннотацию на рантайме?
Если необходимо доступ к аннотации в процессе функционирования приложения. То перед объявлением аннотации задается правило сохранения RUNTIME в виде кода:
Import java.lang.annotation.Retention;
Import java.lang.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
и вызываем на требуемом объекте метод getAnnotation().
 
===================================
===================================

# HashMap.
1.	Сначала ключ проверяется на равенство null. Если это проверка вернула true, будет вызван метод putForNullKey(value) (вариант с добавлением null-ключа рассмотрим чуть позже).
2.	Далее генерируется хэш на основе ключа. Для генерации используется метод hash(hashCode), в который передается key.hashCode().
3.	С помощью метода indexFor(hash, tableLength), определяется позиция в массиве, куда будет помещен элемент.
4.	Теперь, зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается.
5.	Если же предыдущий шаг не выявил совпадений, будет вызван метод addEntry(hash, key, value, index) для добавления нового элемента.
 
===================================
===================================

13. Reflection. JNI.
 Рефлексия (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов. Можно также выполнять операции над полями и методами которые исследуются. Рефлексия в Java осуществляется с помощью Java Reflection API. Этот интерфейс API состоит из классов пакетов java.lang и java.lang.reflect. С помощью интерфейса Java Reflection API можно делать следующее: 
•	Определить класс объекта. 
•	Получить информацию о модификаторах класса, полях, методах, конструкторах и суперклассах.
•	Выяснить, какие константы и методы принадлежат интерфейсу. 
•	Создать экземпляр класса, имя которого неизвестно до момента выполнения программы.
•	Получить и установить значение свойства объекта.
•	Вызвать метод объекта.
•	Создать новый массив, размер и тип компонентов которого неизвестны до момента выполнения программ.
Java Native Interface (JNI) — стандартный механизм для запуска кода, под управлением виртуальной машины Java (JVM), который написан на языках С/С++ или Ассемблера, и скомпонован в виде динамических библиотек, позволяет не использовать статическое связывание. Это даёт возможность вызова функции С/С++ из программы на Java, и наоборот. Более ранние интерфейсы, в отличие от JNI, не удовлетворяли условию двоичной совместимости.
 
===================================
===================================

	16. Что такое API?
Интерфейс программирования приложений (иногда интерфейс прикладного программирования) (англ. application programming interface, API [эй-пи-ай])[1] — набор готовых классов, процедур, функций, структур и констант, предоставляемых приложением (библиотекой, сервисом) для использования во внешних программных продуктах. Используется программистами для написания всевозможных приложений.
API определяет функциональность, которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как именно эта функциональность реализована.
Если программу (модуль, библиотеку) рассматривать как чёрный ящик, то API — это множество «ручек», которые доступны пользователю данного ящика, и которые он может вертеть и дёргать.

===================================
===================================

# Что такое сервер приложений? Что такое веб-сервер, в чём его отличие от сервера приложений? Привести примеры веб-сервера и сервера приложений.
    Сервер приложений  - компонентный сервер, исполняющий приложения для работы с клиентом. Он предоставляет разработчику стандартный фреймворк, контейнер сервлетов итд.
    Веб-сервер – узкоспециализированный сервер, взаимодействующий  с клиентом по протоколу http. Отличается от сервера приложений узкой специализацией.
    Пример веб-сервера  - tomcat, сервера приложений – JBOSS и Glassfish.

===================================
===================================

# Что такое контейнер сервлетов? Что такое сервлет? Методы сервлета.  Жизненный цикл сервлета. 
    Контейнер сервлетов -  программа, управляющая жизненным циклом сервлетов.
    Сервлет – класс, отвечающий за обработку запросов клиента и отправку ответов. Основные методы сервлета: init() – запускается сразу после  загрузки сервлета в память; service() – вызывается для обработки каждого запроса; destroy() – выполняется перед выгрузкой сервлета из памяти.
    Жизненный цикл сервлета: им управляет контейнер сервлетов, при первом обращении к сервлету происходит его загрузка в память и вызывается  метод init(). На протяжении работы приложения происходят вызовы методы service() для обработки запросов клиента. По завершению работы приложения вызывается метод destroy() и сервлет выгружается из памяти.

===================================
===================================

# Что такое сессия?
    Это соединение клиента с сервером, устанавливаемой на определённое время, за которое клиент может сделать любое количество запросов к серверу.

===================================
===================================

# Что нужно написать в браузерной строке, чтобы обратиться к сервлету? Можно ли из браузерной строки напрямую вызвать метод сервлета?
    Надо написать маппинг сервлета. Метод напрямую вызвать нельзя.

===================================
===================================

# Что такое JSP? Жизненный цикл jsp.
    JSP – веб-страница, представляющая собой комбинацию статического html и java-кода. 
    Жизненный цикл JSP. Исходный код jsp, к которой идёт запрос от клиента, анализируется и парсится jsp_engine, далее создаётся временный сервлет, основанный на коде jsp. Далее сервлет компилируется. Запускаются методы init() и jsp_service(). После обработки методом jsp_service() отсылается ответ клиенту в виде html.


===================================
===================================

# Чем отличаются методы GET и POST? Если не указать напрямую, какой из этих методов выполнится по умолчанию. 
    При использовании метода POST данные передаются в зашифрованном виде. В GET есть ограничение на размер передаваемой в запросе строки.
    По умолчанию выполняется GET.

===================================
===================================

# Что такое classpath? Если в classpath есть 2 одинаковые библиотеки (или разные версии одной библиотеки), объект класса из которой библиотеки создастся?
	Classpath – место размещения классов, переменная среды, которая указывается, чтобы показать, где искать классы. 
	Из двух библиотек выберется та, что первой попадётся jvm.

===================================
===================================

# Какие области памяти использует java для размещения простых типов, объектов, функций и.т.д.? 
	Для размещения простых типов и методов java использует стек, для объектов – кучу (heap).

===================================
===================================

# Как работает сборщик мусора в java? Можно ли самому указать сборщику мусора, какой объект удалить из памяти?
	Сборщик мусора автоматически удаляет объект, когда на него не остается ссылок.
	Нельзя самому указать, какой объект удалить.

===================================
===================================

# Транзакции, что такое, для чего используются? Уровни изолированности транзакций. Привести примеры использования.
	Транзакция – несколько операций, выполняемых как одна, либо не выполняемые совсем.
	Используется для запросов к БД, исключающих потерю данных и некорректное взаимодействие с БД. Смысл в том, что если происходит ошибка на этапе выполнения одной из операций, то результат всех операций будет отменён.
	Уровни изолированности:
		Serializable – исключаются все виды ошибок.
		Repeatable read – исключаются все виды ошибок, кроме фантомного чтения.
		Read committed – исключается потеря обновления и грязное чтение. 
		Read uncommitted – исключается только потеря обновлений.
		Пример использования – банковская система: снятие денег со счёта и выдача их клиенту должна проходить как единое действие, поэтому используется транзакция. 

===================================
===================================

# Как сделать запросы к базе данных через jdbc.  Перечислите все этапы. Чем отличается Statement от PreparedStatement? Где сохраняется запрос после первого вызова PreparedStatement? Зачем нужен CallableStatement?
 	Создаётся соединение (либо берётся из пула), создаётся запрос (либо подготавливается), выполняется запрос.
	PreparedStatement не допускает инъекций и при большом количестве запросов, отличающихся только параметрами, даёт лучшую производительность. После первого вызова PreparedStatement сохраняется в кэше СУБД. Обратно возвращается его id и количество параметров. При его выполнении драйвер передаёт в СУБД только id и параметры, а СУБД находит соответствующий запрос, подставляет параметры и выполняет его.  При последующих вызовах этого prepared, СУБД просто находит уже созданный запрос и возвращает его id.
	CallableStatement нужен для вызова хранимых процедур.

===================================
===================================

# Как скомпилировать и запустить класс, используя консоль?   
	Компилируется командой javac имя класса, запускается java имя класса.

===================================
===================================

# Что такое перегрузка метода? Чем отличается от переопределения? Как можно перегрузить метод?
	Перегрузка метода – определение нескольких методов с одинаковым именем метода, но разным количеством или типом входных параметров. 
	При переопределении входные параметры должны быть одинаковы, методы переопределяются только в подклассах.
	Перегрузить метод можно создав метод с таким же именем, но другим количеством или типом параметров.

===================================
===================================

# Каким требованиям должен отвечать xml-документ, чтобы называться well-formed? В чём отличие между понятиями well-formed и valid?
	Well-formed документ должен соответствовать синтаксису xml.
	Valid, в отличие от well-formed, должен соответствовать  схеме.

DOM – создаёт полную древовидную модель xml-документа. Позволяет изменять данные в xml-документе. Применяется, когда нужно получить все данные или внести изменения.
SAX – основана на обработке событий, позволяет извлечь отдельные данные не извлекая остальные.
StAX – работает по тому же принципу, что и SAX. Отличие состоит в том, что разработчик сам указывает, когда перейти к следующему элементу.


===================================
===================================

# Что такое синхронизация? Что такое deadlock? Какие методы синхронизации вы знаете? Для чего нужно ключевое слово synchronized? Для чего применяется ключевое слово volatile?
Синхронизация – обеспечение безопасного взаимодействия нескольких потоков с одним и тем же ресурсом.
deadlock – взаимная блокировка – ситуация, когда один поток взаимодействует с первым ресурсом, блокирует его, и пытается обратиться к другому ресурсу, который используется другим потоком, также блокирующим его. Причём  второй поток пытается обратиться к первому ресурсу. Таким образом, первый поток ждёт освобождения второго ресурса, а второй поток – первого ресурса.
Методы синхронизации: synchronized (синхронизировать метод, синхронизировать блок), использовать concurrent, использовать lock.
synchronized используется, чтобы указать, что данный метод или блок синхронизирован.
volatile используется для того, чтобы объявить переменную, изменения которой в одном потоке будут видны во всех.

Хочу еще разграничить два понятия – поток и процесс. Процесс – это задача операционной системы. У него собственное адресное пространство. С ним может быть проассоциировано несколько потоков. Поток же – это гораздо более мелкая единица. Все потоки разделяют адресное пространство породившего их процесса и имеют доступ к одним данным.
Существует два пути создания потока. Первый – наследование от класса java.lang.Thread и переопределение его метода run. Второй – реализация интерфейса java.lang.Runnable и создание потока на основе этой реализации. В принципе это методы эквивалентны, разница в деталях. Наследование от java.lang.Thread делает его единственным родителем класса, что не всегда удобно. Я лично предпочитаю реализовывать java.lang.Runnable.
В приведенных примерах в методах main создаются потоки, после чего они запускаются на выполнение. Поток завершается, когда произошел выход из метода run, либо если в методе run было выброшено исключение, которое не было обработано. Чаще всего это RuntimeException или наследник, реже – Error или наследник. После того, как поток завершил работу, перестартовать его НЕЛЬЗЯ. Попытка вторичного вызова start приведет к исключению IllegalThreadStateException.

Для того, чтобы уже закончить с классом Thread, коснемся еще нескольких его возможностей.
- Во-первых, у потоков могут быть различные приоритеты. Существует несколько констант – Thread.MIN_PRIORITY == 1, Thread.NORM_PRIORITY == 5 и Thread.MAX_PRIORITY == 10. Значения эти внутренние и с реальными приоритетами потоков в операционной системе соотносятся слабо.
- Во-вторых, потоки могу быть т.н. демонами. Такой поток отличается от обычного тем, что он не препятствует окончанию работы виртуальной машины. Т.е. можно сказать, что виртуальная машина работает, пока существует хотя бы один поток, не являющийся демоном. Потоки-демоны удобно использовать для фоновых задач.
- В-третьих, поток можно приостановить на определенный промежуток времени. Изнутри. Делается это через статический метод Thread.sleep() с параметром – количеством миллисекунд, на которое приостанавливается поток. До истечения этого времени поток может быть выведен из состояния ожидания вызовом interrupt, о котором мы поговорим в следующей части.
- И последнее, чего бы я тут хотел коснуться – статический метод yield. Он служит для передачи управления другим потокам. Т.е. в результате его вызова происходит переключение контекста и процессор начинает исполнять код другого потока. Это нужно как в ситуациях, когда работа на текущий момент завершена и можно дать поработать другим (например, поток обрабатывает данные, все обработал, а новые еще не пришли), так и в ситуациях, когда поток занимается какими-нибудь интенсивными действиями, съедает большую часть процессора и не дает другим потокам работать. Правда, последний подход я встречал только в программировании под Java ME, в условиях ограниченных ресурсов. Обратите внимание, что этот метод статический и действует только на текущий поток. Заставить таким образом чужой поток поделиться своим временем нельзя!

На данный момент мы знаем, как запустить поток на выполнение. Естественный вопрос – а как его остановить? Ответ может оказаться обескураживающим. В Java НЕТ средств для принудительной остановки потока. Вернее, они есть, но использовать их не стоит – метод stop объявлен deprecated. А вместе с ним – и suspend c resume.
Почему это так сделано? Причины, несомненно, есть. Дело в том, что при принудительной остановке (приостановке) потока совершенно непонятно, что делать с ресурсами. Поток может открыть сетевое соединение, например. Что делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? То же самое и про соединение с базой данных. И еще много про что. А если поток остановят посередине транзакции? Кто ее будет закрывать? Кто будет разблокировать ресурсы? В общем, проблем тут существенно больше, чем преимуществ.
Потому – в Java принят уведомительный порядок остановки потока. Вариантов реализации два: либо воспользоваться существующими механизмами, либо создавать такие механизмы вручную. Мы рассмотрим оба варианта и проблемы, связаные с ними.

Вариант первый – использовать существующий механизм. У класса Thread есть такой метод – interrupt. Этот метод выставляет некоторый флаг в дебрях native-кода. В дальнейшем состояние этого флага можно проверить с помощью метода isInterrupted. Существует также статический метод interrupted, который производит проверку для текущего потока. Обратите внимание – вызов этого метода сбрасывает флаг, что подразумевает ответственность разработчика по обработке этой ситуации.
Что хорошо в методе interrupt? Он способен вывести поток из состояния ожидания. Т.е. если у потока были вызваны методы sleep или wait (мы поговорим о нем ниже) – ожидание прервется и будет выброшено исключение InterruptedException. Флаг в этом случае не выставляется, т.к. на брошеное исключение разработчик отреагирует незамедлительно.
Таким образом, действовать нужно так. Реализуете поток (удобнее через наследование от Thread). В потоке периодически вставляете проверки isInterrupted. Если проверка сработала или выброшено исключение во время ожидания – поток пытаются остановить извне. Обращаю внимание – именно остановить, а не ПРИостановить. Вам надо принять решение – либо вы продолжаете работу (если по каким-то причинам не можете остановиться), либо вы освобождаете ресурсы и выходите из метода run. Что вы выберете – зависит от ситуации. Главное – у вас есть возможность маневрировать и делать то, что сочтете нужным. В том числе и продолжать работу. В случае вызова stop такой возможности нет.

Любой нестатический synchronized-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он вызван (на который он может сослаться как на this). Если это удалось – метод исполняется. Если нет – поток останавливается и ждет, пока монитор будет отпущен.

Итак, резюме. Если два нестатических метода объявлены как synchronized, то в каждый момент времени из разных потоков на одном объекте может быть вызван только один из них. Поток, который вызывает метод первым, захватит монитор, и второму потоку придется ждать. Заостряю ваше внимание на трех моментах:
- Это верно только для разных потоков. Один и тот же поток может вызвать синхронизированный метод, внутри него – другой синхронизированный метод на том же экземпляре. Поскольку этот поток владеет монитором, проблем второй вызов не создаст.
- Это верно только для вызовов методов одного экземпляра. У разных экземпляров разные мониторы, потому одновременный вызов нестатических методов проблем не создаст
- В случае статических методов имеет значение только одно – разные ли потоки, вызывающие синхронизированные методы, или нет. Об экземпляре тут речи не идет, его роль исполняет объект класса.

===================================
===================================

# Что такое сериализация, для чего нужна, когда используется? Ключевое слово transient, для чего нужно?
Сериализация – запись объекта в поток. Нужна для передачи данных между разными слоями приложения. Используется, к примеру, когда на jsp надо использовать JavaBean. 
transient указывает на то, что данная переменная не будет сериализована, а при десериализации  ей будет присвоено значение null или 0, если тип базовый.

Существуют 2 способа сериализации. Первый - реализация java.io.Serializable, не требующая никаких усилий. Второй способ – это тоже реализация интерфейса, но уже другого: java.io.Externalizable. В отличие от java.io.Serializable, он содержит два метода, которые необходимо реализовать – writeExternal(ObjectOutput) и readExternal(ObjectInput). В этих методах как раз и находится логика сериализации/десериализации.
Между упомянутыми двумя способами сериализации существует еще одно серьезное отличие. А именно – в механизме десериализации. При использовании Serializable десериализация происходит так: под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается.

То есть при десериализации вызывается конструктор без параметров родительского НЕсериализуемого класса. И если такого конструктора не будет – при десериализации возникнет ошибка. Конструктор же дочернего объекта, того, который мы десериализуем, не вызывается, как и было сказано выше.

Так ведут себя стандартные механизмы при использовании Serializable. При использовании же Externalizable ситуация иная. Сначала вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal, который и вычитывает, собственно, все свои данные. Потому – любой реализующий интерфейс Externalizable класс обязан иметь public конструктор без параметров! Более того, поскольку все наследники такого класса тоже будут считаться реализующими интерфейс Externalizable, у них тоже должен быть конструктор без параметров!
Последний момент – наследование. При наследовании от класса, реализующего Serializable, никаких дополнительных действий предпринимать не надо. Сериализация будет распространяться и на дочерний класс. При наследовании от класса, реализующего Externalizable, необходимо переопределить методы родительского класса readExternal и writeExternal. Иначе поля дочернего класса сериализованы не будут. В этом случае надо бы не забыть вызвать родительские методы, иначе не сериализованы будут уже родительские поля.

Правило 1. После десериализации объекта необходимо проверить его внутреннее состояние (инварианты) на правильность, точно так же, как и при создании с помощью конструктора. Если объект не прошел такую проверку, необходимо инициировать исключение java.io.InvalidObjectException.
Правило 2. Если в составе класса A присутствуют объекты, которые не должны быть доступными для изменения извне, то при десериализации экземпляра класса A необходимо вместо этих объектов создать и сохранить их копии.


===================================
===================================

# Что нужно написать в строке браузера, чтобы обратиться к хосту, на котором установлен томкат, развёрнуто приложение, в котором есть несколько сервлетов? Как обратится к конкретному сервлету? Что такое www? Где нужно указывать порт?
В строке браузера пишется ip-aдрес хоста, номер порта, имя приложения и маппинг сервлета.

===================================
===================================

# Применение классов HttpServletRequestWrapper и HttpServletResponseWrapper.
С помощью этих классов можно изменять запрос и ответ соответственно.

===================================
===================================

# какой последовательности выполняются сервлет фильтры?
В той последовательности, в которой они заданы в FilterChain.

===================================
===================================

# Работа с JSTL тегами.
JSTL позволяет не использовать java код на jsp страницах. В JSTL используется expression language для упрощения доступа к данным, хранящимся в различных областях видимости (page, request, session, application ).
Основные jstl-теги: out,set,remove,if,choose,redirect, import, forEach итд.

===================================
===================================

# Как обрабатывается тег с телом?
Есть методы doStartTag(), doEndTag(), doInitBody(), doAfterBody(), которые запускаются при срабатывании соответствующего события. В них заключается обработка данных, переданных в тег, и вывод результата.

===================================
===================================

# Массивы http://skipy.ru/technics/arrays.html
Большая часть из того, что сказано о массивах примитивных типов, верна и для массивов объектов. Их размер может быть получен через .length, выход за границы контролируется. Создаются они через оператор new:
// array of java.awt.Point with 10 elements:
java.awt.Point[] points = new java.awt.Point[10];
Заметьте, вызова конструктора тут НЕТ. java.awt.Point после оператора new указывает лишь на тип элементов создаваемого массива.

После создания массив точно так же инициализируется значением по умолчанию... И вот тут есть большой подводный камень. Вопрос на засыпку. А каково это значение по умолчанию? Объект, созданный вызовом конструктора без параметров? А если такого конструктора нет? Ответ кроется в ответе на другой вопрос: а что, собственно, хранится в этом массиве?

А хранятся в этом массиве не объекты. Там хранятся ссылки на них. Как любая переменная объектного типа является ссылкой на объект, так и любой элемент массива тоже является ссылкой. А для ссылки значение по умолчанию – null!

Эта ошибка чуть ли не классическая. Очень часто приходится встречать вопросы "откуда тут берется NullPointerException" по отношению к коду следующего вида:

java.awt.Point[] points = new java.awt.Point[10];
points[0].x = 1; // <-- here is a NullPointerException
Теперь, думаю, понятно, откуда берется эта ошибка. Массив создан и его элементы инициализированы значением null. Однако сами объекты не созданы. Ситуация в точности аналогична использованию переменной со значением null. Правильный фрагмент выглядит так:

java.awt.Point[] points = new java.awt.Point[10];
for(int i=0; i<points.length; i++){
    points[i] = new java.awt.Point();
}
// now you can use array
points[0].x = 1; // <-- NO NullPointerException here!

===================================
===================================

# Объекты и ссылки
Итак – ссылки в Java это, фактически, указатели. Однако, в отличие от С, арифметика указателей в Java отсутствует. И хорошо – ничего хорошего, кроме плохого, я от этой возможности не видел. А что вообще можно делать с ссылками? Какие операции над ними можно производить?

Присваивание. Ну это естественно, без этой операции ссылки бы не имели смысла.
Доступ к полям объекта
Вызов методов
Операция приведения типа
Конкатенация строк (оператор '+')
Проверка принадлежности к определенному типу – оператор instanceof
Операции сравнения ссылки – '==' и '!='
Условный оператор ? :

===================================
===================================

# Модификаторы доступа

* private – "моё и только моё". К полям, методам и классам, объявленным private, имеет доступ только класс, в котором они объявлены. Для обозначения этого уровня используется ключевое слово private.
* package – "моё и соседское". К полям, методам и классам, объявленным package, имеет доступ не только класс, в котором они объявлены, но и все классы, находящиеся в том же самом пакете. О том, что представляет собой пакет с точки зрения контроля доступа, речь пойдет ниже. Ключевого слова для обозначения этого уровня доступа, как я уже говорил, нет. Достаточно не указать любой другой.
* protected – "моё и всех наследников". К полям, методам и классам, объявленным protected, имеет доступ класс, в котором они объявлены, все классы, находящиеся в том же самом пакете и все классы, унаследованные от того, где сделано объявление. Для обозначения уровня доступа используется ключевое слово protected.
* public – "всем-всем-всем". К полям, методам и классам, объявленным public доступ имеет кто угодно. С этим уровнем надо обращаться с осторожностью, особенно это касается полей класса – очень легко потерять контроль над тем, кто и где модифицирует переменные. Для обозначения этого уровня доступа используется ключевое слово public.

!! Общее правило применения модификаторов доступа таково – чем больше ограничен доступ, тем лучше.

===================================
===================================

#  Вызовы из конструктора методов, которые возможно переопределить, потенциально опасны тем, что они вызываются в тот момент, когда объект еще не инициализирован до конца – не отработал код дочернего конструктора.
Раннее связывание выполняется для того, чтобы определить, какой именно метод надо вызывать, исходя из имени и набора его параметров. Иначе говоря, на этом этапе компилятор разбирается с перегрузкой.
Позднее связывание служит для того, чтобы разобраться с переопределением. Зная сигнатуру метода, виртуальная машина анализирует объект, на котором этот метод вызывается, чтобы определить, в каком именно классе брать определение вызываемого метода.

===================================
===================================

# Static
Поскольку статический метод – это метод класса, а не экземпляра, переопределить его нельзя. Хотя должен заметить, что вызов статического метода на объекте – дурной тон.
- Вы НЕ можете получить доступ к НЕ статическим членам класса, внутри статического контекста, как вариант, метода или блока.
- В отличие от локальных переменных, статические поля и методы НЕ потокобезопасны (Thread-safe) в Java. 
- Статические методы имеют преимущество в применении, т.к. отсутствует необходимость каждый раз создавать новый объект для доступа к таким методам. Статический метод можно вызвать, используя тип класса, в котором эти методы описаны. Именно поэтому, подобные методы как нельзя лучше подходят в качестве методов-фабрик (factory), и методов-утилит (utility). Класс java.lang.Math — замечательный пример, в котором почти все методы статичны, по этой же причине классы-утилиты в Java финализированы (final).
- Другим важным моментом является то, что вы НЕ можете переопределять (Override) статические методы. Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass) вместо переопределения. Это явление известно как сокрытие методов (hiding methods). Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной. В отличие от переопределения, такие методы не будут выполнены во время работы программы.
-  Модификатор static также может быть объявлен в статичном блоке, более известным как «Статический блок инициализации» (Static initializer block), который будет выполнен во время загрузки класса. Если вы не объявите такой блок, то Java соберёт все статические поля в один список и выполнит его во время загрузки класса. 
- Полезно знать, что статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте. Следовательно, статические методы не могут быть переопределены в Java, т.к. полиморфизм во время выполнения не распространяется на них.
- Важным свойством статического блока является инициализация. Статические поля или переменные инициализируются после загрузки класса в память. Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса.
- Во время сериализации, также как и transient переменные, статические поля не сериализуются.
- И напоследок, поговорим о static import. Данный модификатор имеет много общего со стандартным оператором import, но в отличие от него позволяет импортировать один или все статические члены класса. При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе, аналогично при импортировании полей, мы можем получить доступ без указания имени класса.

У статического метода нет ссылки this!

===================================
===================================

===================================
===================================

===================================
===================================

===================================
===================================

# Аксиомы программирования
	- Если есть возможность воспользоваться чужим опытом – изучи ее.
	- Если ты не понимаешь, что делаешь – делай это тщательно.
	- Программный код должен читаться легче, чем писаться.
	- Качественным является код, максимально приспособленный к поддержке.

В проектировании приложения есть числа 1 и 0. Что означает, что компонент приложения либо есть, либо его нет. В случае возможного присутствия хотя бы двух одинаковых компонентов, стоит считать, что их может быть неопределенное число N и, соответственно, основывать бизнес-логику именно на этом предположении.

Константа есть отражение нашего предположения о том, что некоторая величина имеет заранее определенное постоянное значение.

XP как методология предназначена для уменьшения затрат на разработку и поддержку ПО. При этом она обеспечивает гибкость процесса разработки, качество продукта и его соответствие реальным потребностям заказчика.
...каждая команда должна выбрать наиболее подходящий ей процесс и активно изменять его, подстраивая под нужды конкретного проекта.

В основе существования команды лежат четыре принципа – доверие, равенство, уважение и поддержка.
Лидер – это
а) полноправный член команды,
б) ведущий команду за собой,
в) принимающий решения, направленные на наиболее эффективное достижение цели команды.

В конечном итоге все эти возражения упираются в отсутствие (и даже неприятие!) командных ценностей – доверия, равенства, уважения, поддержки и ответственности. Все эти составляющие жизненно необходимы для успешной реализации практики коллективного владения кодом:

Доверие – я доверяю членам моей команды в том, что они не повесят на меня ответственность за свои ошибки
Равенство – я исправляю любой код, вне зависимости от авторства
Уважение – я уважаю членов команды, поэтому исправляю свои ошибки сам
Поддержка – я исправляю чужие ошибки: мне это несложно, а товарищу по команде – помощь
Ответственность – я отвечаю за свои действия и ошибки





# Даны 2 таблицы: Employee (id_employee, salary, department_id_fk); Department (id_department, department_name). Написать sql-запрос, который выберет названия отделов, суммарная зарплата сотрудников в которых больше 1000. 
	select department_name from Department as dep
	join Employee as emp on dep.id_department=emp.id_employee
	group by dep.department_name
	having sum(eml.salary)>1000


















