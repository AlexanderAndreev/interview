Выделите аспекты приложения, которые могут изменяться, и отделите их от тех, которые всегда остаются постоянными. Все паттерны обеспечивают возможность изменения некторой части системы независимо от других частей. 

- Инкапсулируйте то, что изменяется.
- Отдавайте предпочтение композиции перед наследованием.
- Программируйте на уровне интерфейсов, а не реализации.

ПАТТЕРН СТРАТЕГИЯ определяет семейство алкгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость. Он позволяет модифицировать алгоритмы независимо от их использования на стороне клиента. "Для реализации разных вариантов поведения использоуется паттерн Стратегия". Из этой фразы мы узнаем, что поведение инкапсулируется в отдельном наборе классов, который легко расширяется и изменяется - при необходимости даже во время выполнения.

/* to javascript.txt */

# ОЪЕКТЫ: ПЕРЕБОР СВОЙСТВ

for (key in obj) {
  /* ... делать что-то с obj[key] ... */
}
При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.

Пример итерации по свойствам:
var menu = {
  width: 300,
  height: 200,
  title: "Menu"
};
for (var key in menu) {
  // этот код будет вызван для каждого свойства объекта
  // ..и выведет имя свойства и его значение

  alert( "Ключ: " + key + " значение:" + menu[key] );
}

- Цикл по ключам: for (key in obj).
- Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые — сортируются (в современных браузерах).
- Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +, как описано в примере выше, а потом, в процессе обработки, преобразуют такие ключи в числа.



# ОБЪЕКТЫ: ПЕРЕДАЧА ПО ССЫЛКЕ

Обычные значения: строки, числа, булевы значения, null/undefined при присваивании переменных копируются целиком или, как говорят, «по значению».
	var message = "Привет";
	var phrase = message;
В результате такого копирования получились две полностью независимые переменные, в каждой из которых хранится значение "Привет".

!! При копировании переменной с объектом — копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Так как объект всего один, то изменения через любую переменную видны в других переменных. 


Иногда, на практике — очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.
Что ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов. Если же свойства объектов, в свою очередь, могут хранить ссылки на другие объекты, то нужно обойти такие подобъекты и тоже склонировать их. Это называют «глубоким» клонированием.

- Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.
- Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.
Это — одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью.


/* to angular.txt */




